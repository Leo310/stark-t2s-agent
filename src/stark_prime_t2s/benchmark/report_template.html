<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>STaRK-Prime Benchmark Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@sgratzl/chartjs-chart-boxplot@4/build/index.umd.min.js"></script>
    <style>
      /* ── Design tokens ── */
      :root {
        --bg: #f4f1eb;
        --panel: #ffffff;
        --text: #2b2b2b;
        --muted: #6e6a64;
        --accent: #2f6f6d;
        --accent-soft: #d6e6e5;
        --accent-warm: #c79c5a;
        --accent-green: #6b8f71;
        --border: #e7e2da;
        --danger-bg: #fff8f8;
        --danger-text: #999;
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 18px;
        --pre-bg: #f6f2ec;
        --hover-row: #faf8f4;
        --chart-grid: rgba(0,0,0,0.08);
        --chart-text: #666;
        --nav-bg: #ffffff;
        --nav-active: #2f6f6d;
        --nav-active-bg: #d6e6e5;
        --badge-success: #e6f4ea;
        --badge-success-text: #1e7e34;
        --badge-warn: #fff8e1;
        --badge-warn-text: #f57f17;
        --badge-danger: #fde7e7;
        --badge-danger-text: #c62828;
      }

      [data-theme="dark"] {
        --bg: #1a1a1e;
        --panel: #26262b;
        --text: #e0ddd8;
        --muted: #9a958e;
        --accent: #5abfbc;
        --accent-soft: #2a3f3e;
        --accent-warm: #d4a95f;
        --accent-green: #7faa85;
        --border: #3a3a40;
        --danger-bg: #2e2224;
        --danger-text: #bb8888;
        --pre-bg: #2e2e33;
        --hover-row: #2e2e33;
        --chart-grid: rgba(255,255,255,0.1);
        --chart-text: #aaa;
        --nav-bg: #26262b;
        --nav-active: #5abfbc;
        --nav-active-bg: #2a3f3e;
        --badge-success: #1b3a25;
        --badge-success-text: #7faa85;
        --badge-warn: #3a3020;
        --badge-warn-text: #d4a95f;
        --badge-danger: #3a2020;
        --badge-danger-text: #bb8888;
      }

      /* ── Reset & base ── */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html {
        scroll-behavior: smooth;
      }
      body {
        margin: 0;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        color: var(--text);
        background: var(--bg);
        line-height: 1.5;
      }

      /* ── Header ── */
      header {
        padding: 40px 24px 20px;
        text-align: center;
        position: relative;
      }
      header h1 {
        margin: 0 0 6px;
        font-size: 2rem;
        font-weight: 700;
        letter-spacing: -0.02em;
      }
      header p {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      /* ── Theme toggle ── */
      .theme-toggle {
        position: absolute;
        top: 20px;
        right: 24px;
        background: var(--accent-soft);
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        cursor: pointer;
        padding: 6px 10px;
        font-size: 1.1rem;
        line-height: 1;
        color: var(--text);
        transition: background 0.15s;
      }
      .theme-toggle:hover {
        background: var(--border);
      }

      /* ── Dataset selector ── */
      .dataset-selector {
        position: absolute;
        top: 20px;
        left: 24px;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 10;
      }
      .dataset-selector label {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--muted);
      }
      .dataset-selector select {
        padding: 6px 12px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        background: var(--panel);
        font-size: 0.9rem;
        color: var(--text);
        font-family: inherit;
        cursor: pointer;
        min-width: 220px;
      }
      .dataset-selector select:hover {
        border-color: var(--accent);
      }
      .dataset-selector select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px var(--accent-soft);
      }
      @media (max-width: 700px) {
        .dataset-selector {
          position: static;
          justify-content: center;
          margin-bottom: 12px;
        }
      }

      /* ── Navigation sidebar ── */
      .nav-sidebar {
        position: fixed;
        top: 50%;
        transform: translateY(-50%);
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 2px;
        background: var(--nav-bg);
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        max-height: 80vh;
        overflow-y: auto;
        overflow-x: hidden;
        transition: all 0.2s ease;
        /* Position will be set dynamically by JS, fallback to left edge */
        left: 12px;
      }
      [data-theme="dark"] .nav-sidebar {
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
      .nav-sidebar a {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        border-radius: 6px;
        text-decoration: none;
        color: var(--muted);
        font-size: 0.78rem;
        font-weight: 500;
        white-space: nowrap;
        transition: all 0.15s;
      }
      .nav-sidebar a:hover {
        color: var(--text);
        background: var(--hover-row);
      }
      .nav-sidebar a.active {
        color: var(--nav-active);
        background: var(--nav-active-bg);
        font-weight: 600;
      }
      .nav-sidebar .nav-icon {
        font-size: 1rem;
        width: 20px;
        text-align: center;
        flex-shrink: 0;
      }
      .nav-sidebar .nav-label {
        transition: opacity 0.15s ease, width 0.15s ease;
      }
      
      /* Subsection nav items */
      .nav-sidebar .nav-sub {
        padding-left: 28px;
        font-size: 0.72rem;
        color: var(--muted);
        opacity: 0.85;
      }
      .nav-sidebar .nav-sub:first-of-type {
        margin-top: 4px;
      }
      .nav-sidebar a:not(.nav-sub) + a:not(.nav-sub) {
        margin-top: 8px;
      }
      .nav-sidebar .nav-sub:last-child,
      .nav-sidebar .nav-sub + a:not(.nav-sub) {
        margin-bottom: 0;
      }
      .nav-sidebar a:not(.nav-sub) {
        margin-top: 8px;
      }
      .nav-sidebar a:not(.nav-sub):first-child {
        margin-top: 0;
      }
      .nav-sidebar .nav-sub .nav-icon {
        font-size: 0.7rem;
        width: 14px;
      }
      .nav-sidebar .nav-sub:hover {
        opacity: 1;
      }
      .nav-sidebar .nav-sub.active {
        color: var(--nav-active);
        background: var(--nav-active-bg);
        opacity: 1;
      }
      
      /* Expanded state (default when space available) */
      .nav-sidebar.expanded {
        width: auto;
      }
      .nav-sidebar.expanded .nav-label {
        opacity: 1;
        width: auto;
      }
      
      /* Collapsed state (icons only, expand on hover) */
      .nav-sidebar.collapsed {
        width: 52px;
      }
      .nav-sidebar.collapsed .nav-label {
        opacity: 0;
        width: 0;
        overflow: hidden;
      }
      .nav-sidebar.collapsed .nav-sub {
        display: none;
      }
      .nav-sidebar.collapsed:hover {
        width: auto;
      }
      .nav-sidebar.collapsed:hover .nav-label {
        opacity: 1;
        width: auto;
      }
      .nav-sidebar.collapsed:hover .nav-sub {
        display: flex;
      }
      
      /* Bottom bar for very narrow screens */
      @media (max-width: 900px) {
        .nav-sidebar {
          position: fixed;
          top: auto;
          bottom: 0;
          left: 0 !important;
          right: 0;
          transform: none;
          flex-direction: row;
          border-radius: 0;
          justify-content: center;
          padding: 6px 12px;
          gap: 4px;
          max-height: none;
          overflow-x: auto;
          width: auto !important;
        }
        .nav-sidebar .nav-label {
          display: none !important;
        }
        .nav-sidebar a {
          padding: 8px;
        }
        .nav-sidebar .nav-icon {
          font-size: 1.1rem;
        }
        body { padding-bottom: 52px; }
      }

      /* ── Layout ── */
      main {
        max-width: 1140px;
        margin-left: auto;
        margin-right: auto;
        padding: 0 24px 64px;
        display: grid;
        gap: 24px;
      }

      /* ── Section group labels ── */
      .section-group-label {
        font-size: 0.72rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
        padding: 24px 0 4px;
        border-bottom: 1px solid var(--border);
        margin-bottom: -8px;
      }

      /* ── Panels ── */
      section {
        background: var(--panel);
        border-radius: var(--radius-lg);
        padding: 24px 28px;
        box-shadow: 0 2px 16px rgba(34, 34, 34, 0.06),
                    0 12px 32px rgba(34, 34, 34, 0.04);
        scroll-margin-top: 24px;
        overflow-x: auto;
        max-width: 100%;
      }
      [data-theme="dark"] section {
        box-shadow: 0 2px 16px rgba(0, 0, 0, 0.3),
                    0 12px 32px rgba(0, 0, 0, 0.2);
      }
      h2 {
        margin: 0 0 16px;
        font-size: 1.35rem;
        font-weight: 600;
        letter-spacing: -0.01em;
      }
      h3 {
        margin: 0 0 8px;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text);
      }

      /* ── Section header with collapse toggle ── */
      .section-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        user-select: none;
      }
      .section-header h2 {
        margin-bottom: 0;
      }
      .section-header .collapse-icon {
        font-size: 1.2rem;
        color: var(--muted);
        transition: transform 0.2s;
        flex-shrink: 0;
        margin-left: 8px;
      }
      .section-header .section-subtitle {
        font-size: 0.85rem;
        color: var(--muted);
        font-weight: 400;
        margin-left: 12px;
      }
      .section-body {
        overflow: hidden;
        transition: max-height 0.3s ease, opacity 0.2s ease;
      }
      .section-body.collapsed {
        max-height: 0 !important;
        opacity: 0;
        padding-top: 0;
      }
      .section-body:not(.collapsed) {
        padding-top: 16px;
      }
      .section-header .collapse-icon.rotated {
        transform: rotate(-90deg);
      }

      /* ── Grids ── */
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 16px;
        max-width: 100%;
      }
      .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        max-width: 100%;
      }
      .grid-3 {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 16px;
        max-width: 100%;
      }
      @media (max-width: 700px) {
        .grid-2, .grid-3 {
          grid-template-columns: 1fr;
        }
      }

      /* ── Stat cards ── */
      .stat {
        background: var(--accent-soft);
        border-radius: var(--radius-md);
        padding: 14px 16px;
      }
      .stat h3 {
        margin: 0 0 2px;
        font-size: 0.85rem;
        font-weight: 500;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .stat p {
        margin: 0;
        font-size: 1.35rem;
        font-weight: 700;
        color: var(--accent);
      }
      .stat .stat-detail {
        margin: 4px 0 0;
        font-size: 0.78rem;
        color: var(--muted);
        font-weight: 400;
      }

      /* ── Badges ── */
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }
      .badge-success {
        background: var(--badge-success);
        color: var(--badge-success-text);
      }
      .badge-warn {
        background: var(--badge-warn);
        color: var(--badge-warn-text);
      }
      .badge-danger {
        background: var(--badge-danger);
        color: var(--badge-danger-text);
      }

      /* ── Executive summary cards ── */
      .exec-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        max-width: 100%;
      }
      .exec-card {
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 14px 16px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .exec-card .exec-label {
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }
      .exec-card .exec-value {
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--text);
      }
      .exec-card .exec-detail {
        font-size: 0.78rem;
        color: var(--muted);
      }

      /* ── Metric description tooltips ── */
      .metric-help {
        display: inline-block;
        width: 16px;
        height: 16px;
        line-height: 16px;
        text-align: center;
        border-radius: 50%;
        background: var(--accent-soft);
        color: var(--muted);
        font-size: 0.7rem;
        font-weight: 700;
        cursor: help;
        position: relative;
        vertical-align: middle;
        margin-left: 4px;
      }
      .metric-help:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        padding: 6px 10px;
        background: var(--text);
        color: var(--bg);
        font-size: 0.75rem;
        font-weight: 400;
        border-radius: 6px;
        white-space: nowrap;
        max-width: 280px;
        white-space: normal;
        z-index: 10;
        pointer-events: none;
        margin-bottom: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      }

      /* ── Tables ── */
      .table-wrap {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        max-width: 100%;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
        table-layout: auto;
      }
      th,
      td {
        padding: 8px 10px;
        text-align: left;
        border-bottom: 1px solid var(--border);
      }
      th {
        color: var(--muted);
        font-weight: 600;
        font-size: 0.82rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        position: sticky;
        top: 0;
        background: var(--panel);
      }
      tbody tr:hover {
        background: var(--hover-row);
      }
      .query-cell {
        max-width: 320px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* ── Form controls ── */
      label.muted,
      .muted {
        color: var(--muted);
        font-size: 0.88rem;
      }
      select {
        display: block;
        width: 100%;
        margin-top: 4px;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        background: var(--panel);
        font-size: 0.9rem;
        color: var(--text);
        font-family: inherit;
      }
      select[multiple] {
        min-height: 120px;
        padding: 4px;
      }
      select[multiple] option {
        padding: 6px 10px;
        border-radius: 4px;
        margin: 1px 0;
      }
      select[multiple] option:checked {
        background: var(--accent-soft);
        color: var(--text);
      }

      /* ── Optgroup styling ── */
      select optgroup {
        font-weight: 700;
        font-size: 0.8rem;
        color: var(--muted);
        padding: 6px 4px 2px;
        text-transform: uppercase;
        letter-spacing: 0.03em;
      }
      select optgroup option {
        font-weight: 400;
        font-size: 0.9rem;
        color: var(--text);
        text-transform: none;
        letter-spacing: normal;
        padding-left: 8px;
      }

      /* ── Charts ── */
      .chart-box {
        position: relative;
        height: 300px;
        max-width: 100%;
        overflow: hidden;
      }
      .chart-box canvas {
        width: 100% !important;
        height: 100% !important;
      }

      /* ── Metadata pre ── */
      pre {
        background: var(--pre-bg);
        padding: 12px 16px;
        border-radius: var(--radius-md);
        overflow-x: auto;
        font-size: 0.85rem;
        line-height: 1.6;
        margin: 0;
      }

      /* ── Spacer utility ── */
      .mt { margin-top: 16px; }
      .mt-sm { margin-top: 8px; }
      .mb { margin-bottom: 16px; }

      /* ── Correlation matrix ── */
      .corr-table {
        border-collapse: separate;
        border-spacing: 0;
      }
      .corr-table td,
      .corr-table th {
        text-align: center;
        padding: 6px 6px;
        font-size: 0.82rem;
        min-width: 64px;
      }
      .corr-table tbody th {
        text-align: right;
        white-space: nowrap;
        padding-right: 10px;
        font-size: 0.78rem;
        max-width: 150px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .corr-table thead th {
        vertical-align: bottom;
        padding: 8px 6px;
        white-space: nowrap;
        font-size: 0.78rem;
        background: var(--panel);
      }
      .corr-table thead th:first-child {
        /* empty corner cell */
      }
      .corr-table thead th .corr-col-label {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        justify-content: center;
      }
      .corr-table td.corr-cell {
        font-weight: 600;
        font-variant-numeric: tabular-nums;
      }
      .corr-table td.corr-diag {
        background: var(--accent-soft) !important;
        color: var(--muted);
      }

      /* ── Checkbox styling ── */
      input[type="checkbox"] {
        accent-color: var(--accent);
        width: 16px;
        height: 16px;
      }

      /* ── Dark mode select fix ── */
      [data-theme="dark"] select {
        background: var(--panel);
        color: var(--text);
        border-color: var(--border);
      }
      [data-theme="dark"] select option {
        background: var(--panel);
        color: var(--text);
      }

      /* ── Row failure highlight ── */
      .row-fail { background-color: var(--danger-bg) !important; }

      /* ── Divider between section groups ── */
      .section-divider {
        height: 0;
        margin: 8px 0;
      }

      /* ── Agent & Model color coding ── */
      .agent-chip, .model-chip {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.72rem;
        font-weight: 600;
        letter-spacing: 0.02em;
        white-space: nowrap;
      }
      .agent-chip {
        background: var(--agent-bg, #e8f4f3);
        color: var(--agent-text, #2f6f6d);
        border: 1px solid var(--agent-border, #b8d4d2);
      }
      .model-chip {
        background: var(--model-bg, #f3eee8);
        color: var(--model-text, #8b6f4a);
        border: 1px solid var(--model-border, #d4c8b8);
      }
      .agent-chip .chip-dot, .model-chip .chip-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      /* Agent type colors - unified with tool colors */
      /* SQL = Blue (#5b8db8), SPARQL = Purple (#8b6fad), Search = Brown (#a18262), SQL+SPARQL = Teal (#2f6f6d) */
      .agent-sql-sparql { --agent-bg: #e8f4f3; --agent-text: #2f6f6d; --agent-border: #b8d4d2; }
      .agent-sql { --agent-bg: #e8eef4; --agent-text: #5b8db8; --agent-border: #b8d4e8; }
      .agent-sparql { --agent-bg: #f0e8f4; --agent-text: #8b6fad; --agent-border: #d0b8d4; }
      .agent-search { --agent-bg: #f4efe8; --agent-text: #a18262; --agent-border: #d4c8b8; }

      /* Model colors */
      .model-gpt-5 { --model-bg: #e0f0e0; --model-text: #2d5a2d; --model-border: #a8d4a8; }
      .model-gpt-5-mini { --model-bg: #e8f4e8; --model-text: #5a8b5a; --model-border: #c0e0c0; }

      [data-theme="dark"] .agent-sql-sparql { --agent-bg: #1f3332; --agent-text: #7fc9c6; --agent-border: #3a5a58; }
      [data-theme="dark"] .agent-sql { --agent-bg: #1f2833; --agent-text: #7fa3c9; --agent-border: #3a4a5a; }
      [data-theme="dark"] .agent-sparql { --agent-bg: #2a1f33; --agent-text: #a97fc9; --agent-border: #4a3a5a; }
      [data-theme="dark"] .agent-search { --agent-bg: #332d1f; --agent-text: #c9a97f; --agent-border: #5a523a; }

      [data-theme="dark"] .model-gpt-5 { --model-bg: #1a331a; --model-text: #7fc97f; --model-border: #3a5a3a; }
      [data-theme="dark"] .model-gpt-5-mini { --model-bg: #1f3a1f; --model-text: #a8d4a8; --model-border: #4a6a4a; }

      /* Run name with chips container */
      .run-label {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .run-label-name {
        font-weight: 600;
        font-size: 0.9rem;
      }
      .run-label-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }

      /* Color legend */
      .color-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-top: 12px;
        padding: 12px 16px;
        background: var(--pre-bg);
        border-radius: var(--radius-md);
      }
      .legend-section {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .legend-title {
        font-size: 0.72rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }
      .legend-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      /* Compact chip for tables */
      .chip-compact {
        padding: 1px 6px;
        font-size: 0.68rem;
      }

      /* ── Query Details Section ── */
      .query-detail-card {
        background: var(--pre-bg);
        border-radius: var(--radius-md);
        padding: 16px;
        margin-bottom: 12px;
      }
      .query-detail-card h4 {
        margin: 0 0 8px;
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }
      .query-text {
        font-size: 1rem;
        line-height: 1.6;
        color: var(--text);
      }
      .reasoning-text {
        font-size: 0.9rem;
        line-height: 1.6;
        color: var(--text);
        white-space: pre-wrap;
      }

      /* Tool Call Timeline */
      .tool-timeline {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .tool-call-card {
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        overflow: hidden;
      }
      .tool-call-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        background: var(--accent-soft);
        cursor: pointer;
        user-select: none;
      }
      .tool-call-header:hover {
        background: var(--border);
      }
      .tool-call-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
      }
      .tool-call-badge.search { background: #f4efe8; color: #a18262; }
      .tool-call-badge.sql { background: #e8eef4; color: #5b8db8; }
      .tool-call-badge.sparql { background: #f0e8f4; color: #8b6fad; }
      [data-theme="dark"] .tool-call-badge.search { background: #332d1f; color: #c9a97f; }
      [data-theme="dark"] .tool-call-badge.sql { background: #1f2833; color: #7fa3c9; }
      [data-theme="dark"] .tool-call-badge.sparql { background: #2a1f33; color: #a97fc9; }

      .tool-call-content {
        padding: 12px 14px;
        font-family: 'SF Mono', 'Consolas', monospace;
        font-size: 0.82rem;
        line-height: 1.5;
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 300px;
        overflow-y: auto;
        background: var(--panel);
        border-top: 1px solid var(--border);
      }
      .tool-call-content.collapsed {
        display: none;
      }

      /* Results comparison */
      .results-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
      }
      .result-box {
        padding: 10px 12px;
        border-radius: var(--radius-sm);
        background: var(--panel);
        border: 1px solid var(--border);
      }
      .result-box.correct { border-color: var(--badge-success-text); background: var(--badge-success); }
      .result-box.missed { border-color: var(--badge-danger-text); background: var(--badge-danger); }
      .result-box h5 {
        margin: 0 0 4px;
        font-size: 0.72rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
      }
      .result-box .ids {
        font-family: 'SF Mono', 'Consolas', monospace;
        font-size: 0.85rem;
        word-break: break-all;
      }

      /* Clickable table rows for Item Comparison */
      #compare-score-table tbody tr {
        cursor: pointer;
      }
      #compare-score-table tbody tr:hover {
        outline: 2px solid var(--accent);
        outline-offset: -2px;
      }
      #compare-score-table tbody tr.selected-row {
        outline: 2px solid var(--accent);
        outline-offset: -2px;
        background: var(--accent-soft) !important;
      }

      /* Run selector in summary table */
      #query-runs-table tbody tr {
        cursor: pointer;
      }
      #query-runs-table tbody tr:hover {
        background: var(--hover-row);
      }
      #query-runs-table tbody tr.selected-run {
        background: var(--accent-soft) !important;
        outline: 2px solid var(--accent);
        outline-offset: -2px;
      }
      #query-runs-table .query-group-header {
        font-weight: 500;
      }
      #query-runs-table .query-rep-row {
        font-size: 0.9em;
        background: var(--pre-bg);
      }
      #query-runs-table .query-rep-row:hover {
        background: var(--hover-row) !important;
      }
      #query-runs-table .group-toggle {
        display: inline-block;
        transition: transform 0.15s ease;
      }

      /* ── Metrics Overview Table ── */
      .metrics-table {
        width: 100%;
        border-collapse: collapse;
      }
      .metrics-table th {
        text-align: left;
        padding: 10px 12px;
        background: var(--accent-soft);
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
        border-bottom: 2px solid var(--border);
      }
      .metrics-table td {
        padding: 8px 12px;
        border-bottom: 1px solid var(--border);
        font-size: 0.9rem;
      }
      .metrics-table tr:hover {
        background: var(--hover-row);
      }
      .metrics-table .metric-name {
        font-weight: 500;
        color: var(--text);
      }
      .metrics-table .metric-value {
        font-weight: 700;
        font-variant-numeric: tabular-nums;
        color: var(--accent);
      }
      .metrics-table .metric-detail {
        font-size: 0.8rem;
        color: var(--muted);
      }
      .metrics-table .metric-category {
        font-size: 0.7rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--muted);
        padding: 12px 12px 6px;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
      }
      .metrics-table .metric-bar {
        display: inline-block;
        height: 6px;
        border-radius: 3px;
        background: var(--accent);
        margin-left: 8px;
        vertical-align: middle;
      }
    </style>
  </head>
  <body>
    <!-- ═══ Navigation Sidebar ═══ -->
    <nav class="nav-sidebar expanded" id="nav-sidebar">
      <a href="#sec-executive" data-section="sec-executive"><span class="nav-icon">&#9733;</span><span class="nav-label">Executive Summary</span></a>
      
      <a href="#sec-comparison" data-section="sec-comparison"><span class="nav-icon">&#8644;</span><span class="nav-label">Run Comparison</span></a>
      <a href="#compare-metric-section" data-section="compare-metric-section" class="nav-sub"><span class="nav-icon">&#9679;</span><span class="nav-label">Metrics</span></a>
      <a href="#compare-corr-section" data-section="compare-corr-section" class="nav-sub"><span class="nav-icon">&#9679;</span><span class="nav-label">Correlation</span></a>
      
      <a href="#sec-model-comparison" data-section="sec-model-comparison"><span class="nav-icon">&#9881;</span><span class="nav-label">Model Comparison</span></a>
      <a href="#model-metric-section" data-section="model-metric-section" class="nav-sub"><span class="nav-icon">&#9679;</span><span class="nav-label">Metrics</span></a>
      
      <a href="#sec-deepdive" data-section="sec-deepdive"><span class="nav-icon">&#128269;</span><span class="nav-label">Deep Dive</span></a>
      <a href="#deepdive-metrics" data-section="deepdive-metrics" class="nav-sub"><span class="nav-icon">&#9679;</span><span class="nav-label">Metrics</span></a>
      <a href="#strat-section" data-section="strat-section" class="nav-sub"><span class="nav-icon">&#9679;</span><span class="nav-label">Stratification</span></a>
      <a href="#iteration-section" data-section="iteration-section" class="nav-sub"><span class="nav-icon">&#9679;</span><span class="nav-label">Iterations</span></a>
      <a href="#tool-errors-section" data-section="tool-errors-section" class="nav-sub"><span class="nav-icon">&#9679;</span><span class="nav-label">Tool Errors</span></a>
      
      <a href="#sec-item-comparison" data-section="sec-item-comparison"><span class="nav-icon">&#128203;</span><span class="nav-label">Item Comparison</span></a>
      
      <a href="#sec-failures" data-section="sec-failures"><span class="nav-icon">&#10007;</span><span class="nav-label">Failures</span></a>
    </nav>

    <header>
      <button class="theme-toggle" id="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">&#9790;</button>
      <div class="dataset-selector" id="dataset-selector-container" style="display:none;">
        <label for="dataset-select">Dataset:</label>
        <select id="dataset-select"></select>
      </div>
      <h1>STaRK-Prime Benchmark Report</h1>
      <p>Generated from local benchmark run artifacts.</p>
    </header>

    <main>
      <!-- ═══════════════════════════════════════════════
           SECTION GROUP: Key Results
           ═══════════════════════════════════════════════ -->
      <div class="section-group-label">Key Results</div>

      <!-- ═══ 1. Executive Summary ═══ -->
      <section id="sec-executive">
        <h2>Executive Summary</h2>
        <p class="muted mb">High-level findings across all benchmark runs.</p>
        <div id="color-legend-container"></div>
        <div class="exec-grid mt" id="exec-grid"></div>
        <div class="mt" id="exec-findings"></div>
      </section>

      <!-- ═══════════════════════════════════════════════
           SECTION GROUP: Cross-Run Analysis
           ═══════════════════════════════════════════════ -->
      <div class="section-group-label">Cross-Run Analysis</div>

      <!-- ═══ 3. Run Comparison ═══ -->
      <section id="sec-comparison">
        <div class="section-header" data-target="comparison-body">
          <div>
            <h2 style="display:inline">Run Comparison</h2>
            <span class="section-subtitle">Compare performance across benchmark configurations</span>
          </div>
          <span class="collapse-icon">&#9660;</span>
        </div>
        <div class="section-body" id="comparison-body">
          <div class="grid-2">
            <div>
              <label for="compare-runs" class="muted">Runs</label>
              <select id="compare-runs" multiple size="6"></select>
            </div>
            <div>
              <label for="compare-metric" class="muted">Score metric</label>
              <select id="compare-metric"></select>
              <div id="compare-stack-toggle" class="mt-sm" style="display:none;">
                <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;font-size:0.85rem;">
                  <input type="checkbox" id="compare-stacked-checkbox" checked>
                  <span class="muted">Stack bars (show cumulative contribution)</span>
                </label>
              </div>
            </div>
          </div>

          <div id="compare-metric-section" class="mt">
            <h3 id="compare-metric-title">Metric (mean +/- spread)</h3>
            <p id="compare-metric-description" class="muted" style="font-size:0.85rem;margin-bottom:12px;"></p>
            <div class="chart-box">
              <canvas id="compare-metric-chart"></canvas>
            </div>
          </div>

          <div class="mt" id="compare-corr-section">
            <h3>Run Correlation Matrix</h3>
            <p class="muted">Pearson correlation of per-item scores between selected configurations. High correlation indicates configurations succeed/fail on the same items.</p>
            <div class="table-wrap">
              <table id="compare-corr-matrix-table" class="corr-table"></table>
            </div>
            <p class="muted mt-sm" id="compare-corr-note"></p>
          </div>
        </div>
      </section>

      <!-- ═══ Model Comparison ═══ -->
      <section id="sec-model-comparison">
        <div class="section-header" data-target="model-comparison-body">
          <div>
            <h2 style="display:inline">Model Comparison</h2>
            <span class="section-subtitle">Performance grouped by model family</span>
          </div>
          <span class="collapse-icon">&#9660;</span>
        </div>
        <div class="section-body" id="model-comparison-body">
          <p class="muted mb">Compare performance metrics aggregated across all agent types for each model family.</p>

          <!-- Per Metric Performance by Model -->
          <div id="model-metric-section">
            <div class="grid-2">
              <div>
                <label for="model-metric-select" class="muted">Score metric</label>
                <select id="model-metric-select"></select>
                <div id="model-stack-toggle" class="mt-sm" style="display:none;">
                  <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;font-size:0.85rem;">
                    <input type="checkbox" id="model-stacked-checkbox" checked>
                    <span class="muted">Stack bars (show cumulative contribution)</span>
                  </label>
                </div>
              </div>
              <div></div>
            </div>
            <div class="mt">
              <h3 id="model-metric-title">Metric by Model</h3>
              <p id="model-metric-description" class="muted" style="font-size:0.85rem;margin-bottom:12px;"></p>
              <div class="chart-box">
                <canvas id="model-metric-chart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- ═══════════════════════════════════════════════
           SECTION GROUP: Deep Dives
           ═══════════════════════════════════════════════ -->
      <div class="section-group-label">Deep Dives</div>

      <!-- ═══ Deep Dive Section ═══ -->
      <section id="sec-deepdive">
        <div class="section-header" data-target="deepdive-body">
          <div>
            <h2 style="display:inline">Run Deep Dive</h2>
            <span class="section-subtitle">Detailed analysis of a single run</span>
          </div>
          <span class="collapse-icon">&#9660;</span>
        </div>
        <div class="section-body" id="deepdive-body">
          <div class="mb">
            <label for="deepdive-run" class="muted">Select run to analyze</label>
            <select id="deepdive-run"></select>
          </div>

          <!-- Metrics Overview -->
          <div class="mt" id="deepdive-metrics">
            <h3>Metrics Overview</h3>
            <p class="muted">Comprehensive metrics summary for the selected run configuration.</p>
            <div class="mb" style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
              <label for="baseline-run" class="muted" style="font-size:0.85rem;">Compare against baseline:</label>
              <select id="baseline-run" style="width:auto;min-width:200px;">
                <option value="">None (no comparison)</option>
              </select>
              <span id="baseline-note" class="muted" style="font-size:0.78rem;"></span>
            </div>
            <div class="table-wrap mt">
              <table id="deepdive-metrics-table" class="metrics-table"></table>
            </div>
          </div>

          <!-- Category Stratification -->
          <div class="mt" id="strat-section">
            <h3>Category Stratification</h3>
            <p class="muted">Per-item metrics sliced by derived categories.</p>

            <div class="grid-2">
              <div>
                <label for="strat-dimension" class="muted">Category dimension</label>
                <select id="strat-dimension">
                  <option value="gold_size" selected>Gold answer set size</option>
                  <option value="query_complexity">Query complexity</option>
                  <option value="tool_profile">Tool usage profile</option>
                  <option value="latency_bucket">Latency bucket</option>
                </select>
                <div class="mt">
                  <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Item count by category</h4>
                  <div class="chart-box">
                    <canvas id="strat-count-chart"></canvas>
                  </div>
                </div>
              </div>
              <div>
                <label for="strat-metric" class="muted">Score metric</label>
                <select id="strat-metric"></select>
                <div class="mt">
                  <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Average score by category</h4>
                  <div class="chart-box">
                    <canvas id="strat-bar-chart"></canvas>
                  </div>
                </div>
              </div>
            </div>

          </div>

          <!-- Iteration Analysis -->
          <div class="mt" id="iteration-section">
            <h3>Iteration Analysis</h3>
            <p class="muted">How metrics evolve across agent iterations.</p>
            
            <!-- Iteration Distribution -->
            <div class="mt">
              <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Iteration Distribution</h4>
              <p class="muted" style="font-size:0.8rem;margin-bottom:8px;">Number of items by iteration count. Click a bar to filter the charts below.</p>
              <div class="chart-box" style="height:180px;">
                <canvas id="iteration-distribution-chart"></canvas>
              </div>
            </div>
            
            <!-- Iteration Filter -->
            <div class="mt mb" style="display:flex;align-items:center;gap:12px;">
              <label for="iteration-filter" class="muted" style="font-size:0.85rem;">Show items with exactly</label>
              <select id="iteration-filter" style="width:auto;"></select>
              <span class="muted" style="font-size:0.85rem;">iterations</span>
              <span id="iteration-item-count" class="muted" style="font-size:0.85rem;margin-left:8px;"></span>
            </div>

            <!-- Tool Precision Contribution -->
            <div class="mt">
              <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:8px;">
                <h4 style="font-size:0.9rem;color:var(--muted);margin:0;">Tool Precision Contribution</h4>
                <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;font-size:0.8rem;">
                  <input type="checkbox" id="iteration-precision-stacked-checkbox" checked>
                  <span class="muted">Stack areas</span>
                </label>
              </div>
              <p id="iteration-precision-description" class="muted" style="font-size:0.8rem;margin-bottom:8px;"></p>
              <div class="chart-box">
                <canvas id="iteration-metrics-chart"></canvas>
              </div>
            </div>

            <!-- Tool Contribution -->
            <div class="mt">
              <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Tool Recall Contribution</h4>
              <p class="muted" style="font-size:0.8rem;margin-bottom:8px;">Each tool's contribution to cumulative recall at each iteration.</p>
              <div class="chart-box">
                <canvas id="iteration-tool-contribution-chart"></canvas>
              </div>
            </div>

            <!-- Tool Usage by Iteration -->
            <div class="mt">
              <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Avg Tool Calls by Iteration</h4>
              <p class="muted" style="font-size:0.8rem;margin-bottom:8px;">Average number of tool calls per item at each iteration, stacked by tool type.</p>
              <div class="chart-box">
                <canvas id="iteration-tool-calls-chart"></canvas>
              </div>
            </div>
          </div>

          <!-- Tool Errors Analysis -->
          <div class="mt" id="tool-errors-section" style="border:1px solid var(--border);border-radius:var(--radius-md);padding:12px 16px;">
            <div class="subsection-header" data-target="tool-errors-body" style="cursor:pointer;display:flex;align-items:center;justify-content:space-between;">
              <div>
                <h3 style="margin:0;">Tool Errors Analysis</h3>
                <p class="muted" style="font-size:0.8rem;margin:4px 0 0;">Error categorization and detailed error messages</p>
              </div>
              <span class="collapse-icon rotated" style="font-size:1rem;color:var(--muted);">&#9660;</span>
            </div>
            <div class="subsection-body collapsed" id="tool-errors-body" style="max-height:0;overflow:hidden;opacity:0;transition:max-height 0.3s ease, opacity 0.2s ease;">
              <!-- Error Summary Cards -->
              <div class="exec-grid mt" id="tool-errors-summary-grid"></div>
              
              <!-- Error Category Distribution -->
              <div class="grid-2 mt">
                <div>
                  <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Errors by Category</h4>
                  <div class="chart-box" style="height:220px;">
                    <canvas id="error-category-chart"></canvas>
                  </div>
                </div>
                <div>
                  <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Errors by Tool</h4>
                  <div class="chart-box" style="height:220px;">
                    <canvas id="error-by-tool-chart"></canvas>
                  </div>
                </div>
              </div>

              <!-- Detailed Error Messages -->
              <div class="mt">
                <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Detailed Error Messages</h4>
                <p class="muted" style="font-size:0.8rem;margin-bottom:8px;">Most common error messages encountered during tool execution.</p>
                <div class="table-wrap" style="max-height: 400px; overflow-y: auto;">
                  <table id="detailed-errors-table"></table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- ═══════════════════════════════════════════════
           SECTION GROUP: Item Analysis
           ═══════════════════════════════════════════════ -->
      <div class="section-group-label">Item Analysis</div>

      <!-- ═══ Item Comparison ═══ -->
      <section id="sec-item-comparison">
        <div class="section-header" data-target="item-comparison-body">
          <div>
            <h2 style="display:inline">Item Comparison</h2>
            <span class="section-subtitle">Per-query analysis across runs</span>
          </div>
          <span class="collapse-icon">&#9660;</span>
        </div>
        <div class="section-body" id="item-comparison-body">
          <p class="muted">Per-item score breakdown across selected runs. Use this to identify which queries perform differently across configurations.</p>
          <div class="grid-2" style="margin-top:12px;">
            <div>
              <label for="item-compare-metric" class="muted">Score metric</label>
              <select id="item-compare-metric"></select>
            </div>
            <div></div>
          </div>
          <div class="table-wrap" style="max-height: 600px; overflow-y: auto; margin-top:12px;">
            <table id="compare-score-table"></table>
          </div>

          <!-- Query Details Subsection -->
          <div class="mt" id="query-details-section" style="margin-top:24px;">
            <h3>Query Details</h3>
            <p class="muted">Click a row in the table above or select a query to see detailed analysis including agent reasoning and tool calls.</p>
            
            <div class="grid-2" style="margin-top:12px;">
              <div>
                <label for="query-detail-select" class="muted">Select Query</label>
                <select id="query-detail-select"></select>
              </div>
              <div></div>
            </div>
            
            <!-- Quick Comparison Summary Table -->
            <div class="mt" id="query-runs-summary" style="margin-top:16px;">
              <h4 style="font-size:0.9rem;color:var(--muted);margin:0 0 8px;">Performance Across Runs</h4>
              <div class="table-wrap" style="max-height:350px;overflow-y:auto;">
                <table id="query-runs-table"></table>
              </div>
            </div>
            
            <!-- Detailed View for Selected Run -->
            <div class="mt" id="query-detail-content" style="display:none;margin-top:16px;">
              <!-- Populated dynamically by JavaScript -->
            </div>
          </div>
        </div>
      </section>

      <!-- ═══ Failures (hidden when no failures) ═══ -->
      <section id="sec-failures" style="display:none;">
        <div class="section-header" data-target="failures-body">
          <div>
            <h2 style="display:inline">Failures</h2>
            <span class="section-subtitle">Error analysis</span>
          </div>
          <span class="collapse-icon">&#9660;</span>
        </div>
        <div class="section-body" id="failures-body">
          <div class="grid-2">
            <div>
              <h3>Error counts</h3>
              <div class="table-wrap">
                <table id="failure-counts-table"></table>
              </div>
            </div>
            <div>
              <h3>Failure details</h3>
              <div class="table-wrap">
                <table id="failure-details-table"></table>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <!-- Apply saved theme immediately to prevent flash -->
    <script>
      (function() {
        const saved = localStorage.getItem('stark-report-theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (saved === 'dark' || (!saved && prefersDark)) {
          document.documentElement.setAttribute('data-theme', 'dark');
        }
      })();
    </script>

    <script>
      /* ═══════════════════════════════════════════════
       *  Data injected by Python via string.Template
       * ═══════════════════════════════════════════════ */
      const report = $report_json;

      /* ── Shared chart defaults ── */
      Chart.defaults.font.family = "'Inter', 'Segoe UI', system-ui, sans-serif";
      Chart.defaults.font.size = 12;
      Chart.defaults.plugins.legend.display = false;

      function isDarkMode() {
        return document.documentElement.getAttribute('data-theme') === 'dark';
      }

      function applyChartTheme() {
        const dark = isDarkMode();
        const gridColor = dark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)';
        const textColor = dark ? '#aaa' : '#666';
        Chart.defaults.color = textColor;
        Object.values(Chart.instances).forEach(chart => {
          const scales = chart.options?.scales || {};
          for (const axis of Object.values(scales)) {
            axis.ticks = axis.ticks || {};
            axis.ticks.color = textColor;
            axis.grid = axis.grid || {};
            axis.grid.color = gridColor;
          }
          chart.update('none');
        });
      }

      applyChartTheme();

      const COLORS = {
        // Semantic colors for outcomes
        success: '#6b8f71',   // Green - correct/good outcomes
        warning: '#d4763b',   // Orange - partial/missed opportunities  
        error:   '#c45a5a',   // Red - failures/not found
        
        // Tool colors (consistent across all charts)
        sql:     '#5b8db8',   // Blue for SQL
        sparql:  '#8b6fad',   // Purple for SPARQL
        search:  '#a18262',   // Brownish/warm for Search
        
        // Neutral/utility colors
        accent:  '#2f6f6d',   // Teal accent
        gray:    '#8a8a8a',   // Neutral gray
        
        // Legacy aliases (for backward compatibility)
        green:   '#6b8f71',
        orange:  '#d4763b',
        red:     '#c45a5a',
        blue:    '#5b8db8',
        purple:  '#8b6fad',
        warm:    '#a18262',
      };

      /* ── Tool color mapping (for charts) ── */
      const TOOL_COLORS = {
        'search_entities_tool':       COLORS.search,
        'execute_sql_query_tool':     COLORS.sql,
        'execute_sparql_query_tool':  COLORS.sparql,
      };

      /* ── Agent & Model color mappings ── */
      const AGENT_COLORS = {
        'sql-sparql': { light: '#2f6f6d', dark: '#7fc9c6', name: 'SQL+SPARQL' },
        'sql':        { light: '#5b8db8', dark: '#7fa3c9', name: 'SQL Only' },
        'sparql':     { light: '#8b6fad', dark: '#a97fc9', name: 'SPARQL Only' },
        'search':     { light: '#a18262', dark: '#c9a97f', name: 'Search Only' },
      };

      const MODEL_COLORS = {
        'gpt-5':      { light: '#2d5a2d', dark: '#7fc97f', name: 'GPT-5' },
        'gpt-5-mini': { light: '#5a8b5a', dark: '#a8d4a8', name: 'GPT-5-mini' },
      };

      /* ── Error category colors (semantic) ── */
      const ERROR_CATEGORY_COLORS = {
        'syntax': COLORS.warning,      // Orange - fixable errors
        'not_found': COLORS.purple,    // Purple - missing resources
        'permission': COLORS.error,    // Red - access issues
        'timeout': COLORS.blue,        // Blue - performance issues
        'connection': COLORS.gray,     // Gray - infrastructure
        'type_error': '#e67e22',       // Dark orange - type mismatches
        'constraint': '#9b59b6',       // Violet - constraint violations
        'resource': '#c0392b',         // Dark red - resource limits
        'other': COLORS.gray,
      };

      function getErrorCategoryColor(category) {
        return ERROR_CATEGORY_COLORS[category] || ERROR_CATEGORY_COLORS.other;
      }

      // Display names for computed metrics (used across multiple sections)
      const METRIC_DISPLAY_NAMES = {
        'tool_precision': 'Tool Precision',
        'tool_recall': 'Tool Recall', 
        'missed_opportunity_rate': 'Missed Opportunity Rate',
        'latency': 'Latency (s)',
        'tool_usage': 'Tool Usage',
        'tool_error_rate': 'Tool Error Rate (per call)',
        'zero_result_rate': 'Zero Result Rate (per call)',
        'iterations': 'Iterations',
        'avg_f1': 'F1 Score',
        'avg_recall': 'Recall',
        'avg_precision': 'Precision',
        'f1': 'F1 Score',
        'recall': 'Recall',
        'precision': 'Precision',

        'hit@1': 'Hit@1',
        'hit@5': 'Hit@5',
        'hit@10': 'Hit@10',
        'hit@20': 'Hit@20',
        'avg_hit@1': 'Hit@1',
        'avg_hit@5': 'Hit@5',
        'avg_hit@10': 'Hit@10',
        'avg_hit@20': 'Hit@20',
        'mrr': 'MRR',
        'avg_mrr': 'MRR',
      };

      // Metric grouping for dropdown organization
      const METRIC_GROUPS = {
        'Agent Effectiveness': {
          metrics: [
            'avg_f1', 'f1', 'avg_recall', 'recall', 'avg_precision', 'precision',
            'hit@1', 'hit@5', 'hit@10', 'hit@20',
            'avg_hit@1', 'avg_hit@5', 'avg_hit@10', 'avg_hit@20',
            'mrr', 'avg_mrr',
            'missed_opportunity_rate'
          ],
          description: 'How well the agent answers queries'
        },
        'Agent Efficiency': {
          metrics: ['latency', 'tool_usage', 'iterations'],
          description: 'Resource usage and speed'
        },
        'Tool Effectiveness': {
          metrics: ['tool_precision', 'tool_recall'],
          description: 'How well tools find correct entities'
        },
        'Tool Efficiency': {
          metrics: ['tool_error_rate', 'zero_result_rate'],
          description: 'Tool reliability and success rate'
        },
      };
      
      // Tool metrics that should display with per-tool breakdown (stacked for usage, grouped for rates)
      const TOOL_STACKED_METRICS = ['tool_usage', 'tool_error_rate', 'zero_result_rate', 'tool_precision', 'tool_recall'];

      /**
       * Build grouped metric options HTML using optgroup elements.
       * Only includes metrics that belong to defined groups.
       * Deduplicates metrics with same display name (prefers avg_ version).
       * @param {Set} availableMetrics - Set of metric names available in the data
       * @param {string} defaultMetric - The metric to select by default
       * @returns {string} HTML string for select options
       */
      function buildGroupedMetricOptionsHTML(availableMetrics, defaultMetric) {
        let html = '';
        
        // Build grouped options - only include metrics that belong to a group
        for (const [groupName, groupInfo] of Object.entries(METRIC_GROUPS)) {
          const groupMetrics = groupInfo.metrics.filter(m => availableMetrics.has(m));
          if (groupMetrics.length === 0) continue;
          
          // Deduplicate metrics with same display name
          // Prefer avg_ version over non-prefixed version
          const seenDisplayNames = new Set();
          const dedupedMetrics = [];
          
          groupMetrics.forEach(m => {
            const displayName = METRIC_DISPLAY_NAMES[m] || m;
            if (seenDisplayNames.has(displayName)) {
              // Already have this display name - check if we should replace
              const existingIdx = dedupedMetrics.findIndex(
                existing => (METRIC_DISPLAY_NAMES[existing] || existing) === displayName
              );
              if (existingIdx !== -1) {
                const existing = dedupedMetrics[existingIdx];
                // Prefer avg_ prefixed version
                if (m.startsWith('avg_') && !existing.startsWith('avg_')) {
                  dedupedMetrics[existingIdx] = m;
                }
              }
            } else {
              seenDisplayNames.add(displayName);
              dedupedMetrics.push(m);
            }
          });
          
          html += '<optgroup label="' + escapeHtml(groupName) + '">';
          dedupedMetrics.forEach(m => {
            const displayName = METRIC_DISPLAY_NAMES[m] || m;
            const selected = m === defaultMetric ? ' selected' : '';
            html += '<option value="' + m + '"' + selected + '>' + escapeHtml(displayName) + '</option>';
          });
          html += '</optgroup>';
        }
        
        return html;
      }

      /**
       * Parse agent type from run name.
       * Examples: "sql-only-agent-gpt-5-mini" -> "sql"
       *           "sparql-only-agent-claude-3" -> "sparql"
       *           "sql-sparql-agent-gpt-4" -> "sql-sparql"
       *           "search-only-agent-gpt-4" -> "search"
       */
      function parseAgentType(runName) {
        const lower = runName.toLowerCase();
        // Check for combined SQL+SPARQL agent
        if (lower.includes('sql-sparql') || lower.includes('sparql-sql')) return 'sql-sparql';
        // Check for search-only
        if (lower.includes('search-only') || lower.includes('search-agent')) return 'search';
        // Check for SQL-only
        if (lower.includes('sql-only') || (lower.includes('sql-agent') && !lower.includes('sparql'))) return 'sql';
        // Check for SPARQL-only
        if (lower.includes('sparql-only') || (lower.includes('sparql-agent') && !lower.includes('sql'))) return 'sparql';
        // Default fallback to sql-sparql (full agent)
        return 'sql-sparql';
      }

      /**
       * Parse model from run name or metadata.
       * Examples: "gpt-5-mini" -> "gpt-5-mini"
       *           "gpt-5" -> "gpt-5"
       */
      function parseModelFamily(runNameOrModel) {
        const lower = runNameOrModel.toLowerCase();
        if (lower.includes('gpt-5-mini')) return 'gpt-5-mini';
        if (lower.includes('gpt-5')) return 'gpt-5';
        // Fallback to gpt-5 for unknown
        return 'gpt-5';
      }

      /**
       * Extract model name from run name.
       * Pattern: "{agent-type}-{model-name}-rep-{N}" or "{agent-type}-{model-name}"
       */
      function extractModelName(runName) {
        // Strip -rep-N suffix first
        let name = runName.replace(/-rep-\d+$/, '');
        
        // Try to extract model after agent prefix
        const agentPrefixes = [
          'sql-sparql-agent-', 'sparql-sql-agent-',
          'sql-only-agent-', 'sparql-only-agent-', 'search-only-agent-',
          'entity-resolver-agent-', 'auto-agent-', 'prime-agent-', 
          'stark-prime-agent-', 'sql-agent-', 'sparql-agent-', 'search-agent-'
        ];
        
        for (const prefix of agentPrefixes) {
          if (name.toLowerCase().startsWith(prefix)) {
            return name.slice(prefix.length);
          }
        }
        
        // Fallback: try to find model patterns
        const modelPatterns = /(?:gpt|claude|gemini|llama|mistral|mixtral)[-\w]*/i;
        const match = name.match(modelPatterns);
        return match ? match[0] : name;
      }

      /**
       * Get agent color for current theme.
       */
      function getAgentColor(agentType) {
        const agent = AGENT_COLORS[agentType] || AGENT_COLORS.auto;
        return isDarkMode() ? agent.dark : agent.light;
      }

      /**
       * Get model color for current theme.
       */
      function getModelColor(modelFamily) {
        const model = MODEL_COLORS[modelFamily] || MODEL_COLORS.other;
        return isDarkMode() ? model.dark : model.light;
      }

      /**
       * Create an agent chip HTML element.
       */
      function createAgentChip(agentType, compact = false) {
        const agent = AGENT_COLORS[agentType] || AGENT_COLORS.auto;
        const cls = compact ? 'agent-chip chip-compact' : 'agent-chip';
        const color = isDarkMode() ? agent.dark : agent.light;
        return '<span class="' + cls + ' agent-' + agentType + '">' +
               '<span class="chip-dot" style="background:' + color + '"></span>' +
               agent.name + '</span>';
      }

      /**
       * Create a model chip HTML element.
       */
      function createModelChip(modelFamily, modelName, compact = false) {
        const model = MODEL_COLORS[modelFamily] || MODEL_COLORS['gpt-5'];
        const cls = compact ? 'model-chip chip-compact' : 'model-chip';
        const color = isDarkMode() ? model.dark : model.light;
        const displayName = model.name;
        return '<span class="' + cls + ' model-' + modelFamily + '">' +
               '<span class="chip-dot" style="background:' + color + '"></span>' +
               escapeHtml(displayName) + '</span>';
      }

      /**
       * Create a run label with agent and model chips only (no raw run name).
       */
      function createRunLabel(runName, compact = true) {
        const agentType = parseAgentType(runName);
        const modelName = extractModelName(runName);
        const modelFamily = parseModelFamily(modelName);
        
        return '<div class="run-label-chips" style="display:flex;flex-wrap:wrap;gap:4px;">' +
               createAgentChip(agentType, compact) +
               createModelChip(modelFamily, modelName, compact) +
               '</div>';
      }

      /**
       * Sort order for agent types and model families.
       * Lower index = higher priority (shown first).
       */
      const AGENT_SORT_ORDER = ['search', 'sql', 'sparql', 'sql-sparql'];
      const MODEL_SORT_ORDER = ['gpt-5-mini', 'gpt-5'];
      
      /**
       * Compare two run names for sorting.
       * Order: search -> sql -> sparql -> sql-sparql, then gpt-5-mini -> gpt-5
       * @param {string} a - First run name
       * @param {string} b - Second run name
       * @returns {number} Comparison result (-1, 0, 1)
       */
      function compareRunNames(a, b) {
        const agentA = parseAgentType(a);
        const agentB = parseAgentType(b);
        const modelA = parseModelFamily(extractModelName(a));
        const modelB = parseModelFamily(extractModelName(b));
        
        // First sort by agent type
        const agentIdxA = AGENT_SORT_ORDER.indexOf(agentA);
        const agentIdxB = AGENT_SORT_ORDER.indexOf(agentB);
        const agentOrderA = agentIdxA === -1 ? 999 : agentIdxA;
        const agentOrderB = agentIdxB === -1 ? 999 : agentIdxB;
        
        if (agentOrderA !== agentOrderB) {
          return agentOrderA - agentOrderB;
        }
        
        // Then sort by model family
        const modelIdxA = MODEL_SORT_ORDER.indexOf(modelA);
        const modelIdxB = MODEL_SORT_ORDER.indexOf(modelB);
        const modelOrderA = modelIdxA === -1 ? 999 : modelIdxA;
        const modelOrderB = modelIdxB === -1 ? 999 : modelIdxB;
        
        if (modelOrderA !== modelOrderB) {
          return modelOrderA - modelOrderB;
        }
        
        // Finally sort alphabetically by full name
        return a.localeCompare(b);
      }
      
      /**
       * Sort an array of run names using the standard ordering.
       * @param {string[]} runNames - Array of run names
       * @returns {string[]} Sorted array
       */
      function sortRunNames(runNames) {
        return [...runNames].sort(compareRunNames);
      }
      
      /**
       * Sort an array of run objects (with run_name property) using the standard ordering.
       * @param {Array<{run_name: string}>} runs - Array of run objects
       * @returns {Array} Sorted array
       */
      function sortRuns(runs) {
        return [...runs].sort((a, b) => compareRunNames(a.run_name, b.run_name));
      }

      /**
       * Generate color legend HTML.
       */
      function generateColorLegend() {
        let html = '<div class="color-legend">';
        
        // Agent colors
        html += '<div class="legend-section">';
        html += '<span class="legend-title">Agent Types</span>';
        html += '<div class="legend-items">';
        for (const [key, agent] of Object.entries(AGENT_COLORS)) {
          html += createAgentChip(key, true);
        }
        html += '</div></div>';
        
        // Model colors
        html += '<div class="legend-section">';
        html += '<span class="legend-title">Models</span>';
        html += '<div class="legend-items">';
        for (const [key, model] of Object.entries(MODEL_COLORS)) {
          html += createModelChip(key, null, true);
        }
        html += '</div></div>';
        
        html += '</div>';
        return html;
      }

      function fmt(value, precision) {
        if (value === null || value === undefined || Number.isNaN(value)) return '-';
        return Number(value).toFixed(precision === undefined ? 3 : precision);
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }

      function makeBarChart(canvas, labels, data, color) {
        return new Chart(canvas, {
          type: 'bar',
          data: {
            labels,
            datasets: [{ data, backgroundColor: color || COLORS.accent }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { maxRotation: 60, minRotation: 30, autoSkip: true } },
              y: { beginAtZero: true, ticks: { precision: 0 } },
            },
          },
        });
      }

      function makeBoxPlotChart(canvas, labels, dataArrays, color) {
        const baseColor = color || COLORS.accent;
        const bgColor = baseColor + '66';
        return new Chart(canvas, {
          type: 'boxplot',
          data: {
            labels,
            datasets: [{
              label: '',
              data: dataArrays,
              backgroundColor: bgColor,
              borderColor: baseColor,
              borderWidth: 1,
              outlierBackgroundColor: baseColor,
              outlierBorderColor: baseColor,
              outlierRadius: 2,
              meanBackgroundColor: COLORS.warm,
              meanBorderColor: COLORS.warm,
              meanRadius: 3,
              itemRadius: 0,
              padding: 10,
              medianColor: baseColor,
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { maxRotation: 60, minRotation: 30, autoSkip: true } },
              y: { beginAtZero: true },
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function(ctx) {
                    const v = ctx.parsed;
                    if (!v || typeof v !== 'object') return '';
                    return [
                      'Min: ' + fmt(v.whiskerMin),
                      'Q1: ' + fmt(v.q1),
                      'Median: ' + fmt(v.median),
                      'Mean: ' + fmt(v.mean),
                      'Q3: ' + fmt(v.q3),
                      'Max: ' + fmt(v.whiskerMax),
                    ];
                  }
                }
              }
            },
          },
        });
      }

      function summarize(arr) {
        if (!arr || arr.length === 0) return { mean: null, sd: null, min: null, max: null, n: 0, values: [] };
        const n = arr.length;
        const mean = arr.reduce((s, v) => s + v, 0) / n;
        const variance = n > 1 ? arr.reduce((s, v) => s + (v - mean) ** 2, 0) / (n - 1) : 0;
        const sd = Math.sqrt(variance);
        const sorted = [...arr].sort((a, b) => a - b);
        return { mean, sd, min: sorted[0], max: sorted[n - 1], n, values: arr };
      }

      function fmtSpread(summary, precision) {
        const p = precision === undefined ? 3 : precision;
        if (!summary || summary.mean === null) return '-';
        if (summary.n <= 1) return fmt(summary.mean, p);
        return fmt(summary.mean, p) + ' +/- ' + fmt(summary.sd, p);
      }

      /**
       * Chart.js plugin: error-bar whiskers on bar charts.
       */
      const errorBarPlugin = {
        id: 'errorBarWhiskers',
        afterDatasetsDraw(chart) {
          const ctx = chart.ctx;
          chart.data.datasets.forEach((ds, dsIdx) => {
            const errorBars = ds.errorBars;
            if (!errorBars) return;
            const meta = chart.getDatasetMeta(dsIdx);
            meta.data.forEach((bar, i) => {
              const eb = errorBars[i];
              if (!eb || eb.min === null || eb.max === null) return;
              if (eb.min === eb.max) return;
              const yScale = chart.scales.y;
              const yMin = yScale.getPixelForValue(eb.min);
              const yMax = yScale.getPixelForValue(eb.max);
              const x = bar.x;
              const capW = Math.min(bar.width * 0.4, 12);

              ctx.save();
              ctx.strokeStyle = ds.borderColor || '#333';
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.moveTo(x, yMin);
              ctx.lineTo(x, yMax);
              ctx.moveTo(x - capW, yMin);
              ctx.lineTo(x + capW, yMin);
              ctx.moveTo(x - capW, yMax);
              ctx.lineTo(x + capW, yMax);
              ctx.stroke();
              ctx.restore();
            });
          });
        }
      };
      Chart.register(errorBarPlugin);

      /**
       * Chart.js plugin: colored chip labels on x-axis.
       * Use by setting options.plugins.chipLabels.labels = [{agent, model, agentColor, modelColor}, ...]
       */
      const chipLabelsPlugin = {
        id: 'chipLabels',
        afterDraw(chart) {
          const chipConfig = chart.options.plugins?.chipLabels;
          if (!chipConfig?.labels) return;
          
          const ctx = chart.ctx;
          const xAxis = chart.scales.x;
          const labels = chipConfig.labels;
          
          // Draw chips below the x-axis
          const baseY = xAxis.bottom + 8;
          
          labels.forEach((label, i) => {
            const x = xAxis.getPixelForValue(i);
            if (!label) return;
            
            ctx.save();
            
            // Chip dimensions - matching CSS .agent-chip, .model-chip styles
            const chipHeight = 18;
            const chipPadding = 6;
            const dotRadius = 4;
            const chipGap = 4;
            const fontSize = 11;
            ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
            
            // Measure text widths
            const agentText = label.agent || '';
            const modelText = label.model || '';
            const agentTextWidth = ctx.measureText(agentText).width;
            const modelTextWidth = ctx.measureText(modelText).width;
            const agentChipWidth = agentTextWidth + dotRadius * 2 + chipPadding * 2 + 6;
            const modelChipWidth = modelTextWidth + dotRadius * 2 + chipPadding * 2 + 6;
            
            // Draw agent chip (first line)
            const agentY = baseY;
            const agentX = x - agentChipWidth / 2;
            
            // Agent chip background
            ctx.fillStyle = label.agentBg || '#e8f4f3';
            ctx.beginPath();
            ctx.roundRect(agentX, agentY, agentChipWidth, chipHeight, 9);
            ctx.fill();
            
            // Agent dot
            ctx.fillStyle = label.agentColor || '#2f6f6d';
            ctx.beginPath();
            ctx.arc(agentX + chipPadding + dotRadius, agentY + chipHeight / 2, dotRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Agent text
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = label.agentColor || '#2f6f6d';
            ctx.fillText(agentText, agentX + chipPadding + dotRadius * 2 + 5, agentY + chipHeight / 2);
            
            // Draw model chip (second line)
            const modelY = agentY + chipHeight + chipGap;
            const modelX = x - modelChipWidth / 2;
            
            // Model chip background
            ctx.fillStyle = label.modelBg || '#f3eee8';
            ctx.beginPath();
            ctx.roundRect(modelX, modelY, modelChipWidth, chipHeight, 9);
            ctx.fill();
            
            // Model dot
            ctx.fillStyle = label.modelColor || '#8b6f4a';
            ctx.beginPath();
            ctx.arc(modelX + chipPadding + dotRadius, modelY + chipHeight / 2, dotRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Model text
            ctx.fillStyle = label.modelColor || '#8b6f4a';
            ctx.fillText(modelText, modelX + chipPadding + dotRadius * 2 + 5, modelY + chipHeight / 2);
            
            ctx.restore();
          });
        }
      };
      Chart.register(chipLabelsPlugin);

      function makeBarWithErrorChart(canvas, labels, summaries, color) {
        const baseColor = color || COLORS.accent;
        const bgColor = baseColor + '88';
        return new Chart(canvas, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              data: summaries.map(s => s.mean),
              backgroundColor: bgColor,
              borderColor: baseColor,
              borderWidth: 1,
              errorBars: summaries.map(s =>
                s.n > 1 ? { min: s.min, max: s.max } : null
              ),
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { maxRotation: 60, minRotation: 30, autoSkip: true } },
              y: { beginAtZero: true },
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function(ctx) {
                    const s = summaries[ctx.dataIndex];
                    if (!s || s.mean === null) return '';
                    if (s.n <= 1) return 'Value: ' + fmt(s.mean);
                    return [
                      'Mean: ' + fmt(s.mean),
                      'SD: ' + fmt(s.sd),
                      'Min: ' + fmt(s.min),
                      'Max: ' + fmt(s.max),
                      'Reps: ' + s.n,
                    ];
                  }
                }
              }
            },
          },
        });
      }

      /**
       * Bar chart with error bars and per-bar colors based on agent/model.
       */
      function makeBarWithErrorChartMultiColor(canvas, labels, summaries, colors) {
        const bgColors = colors.map(c => c + '88');
        return new Chart(canvas, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              data: summaries.map(s => s.mean),
              backgroundColor: bgColors,
              borderColor: colors,
              borderWidth: 2,
              errorBars: summaries.map(s =>
                s.n > 1 ? { min: s.min, max: s.max } : null
              ),
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { maxRotation: 60, minRotation: 30, autoSkip: true } },
              y: { beginAtZero: true },
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function(ctx) {
                    const s = summaries[ctx.dataIndex];
                    if (!s || s.mean === null) return '';
                    if (s.n <= 1) return 'Value: ' + fmt(s.mean);
                    return [
                      'Mean: ' + fmt(s.mean),
                      'SD: ' + fmt(s.sd),
                      'Min: ' + fmt(s.min),
                      'Max: ' + fmt(s.max),
                      'Reps: ' + s.n,
                    ];
                  }
                }
              }
            },
          },
        });
      }

      /* ═══════════════════════════════════════════════
       *  Dataset Selection Support
       * ═══════════════════════════════════════════════ */

      // Global state for current dataset
      let currentDatasetKey = report.default_dataset || 'human';

      // Check if multiple datasets are available
      const hasMultipleDatasets = report.has_multiple_datasets && report.datasets;

      /**
       * Get current dataset's data.
       * Returns { compare_runs, all_runs, primary_run }.
       */
      function getCurrentDataset() {
        if (hasMultipleDatasets) {
          return report.datasets[currentDatasetKey] || Object.values(report.datasets)[0];
        }
        // Single dataset mode - return top-level data
        return {
          compare_runs: report.compare_runs || [],
          all_runs: report.all_runs || {},
          primary_run: report.primary_run
        };
      }

      /**
       * Get compare_runs for current dataset.
       */
      function getCompareRuns() {
        return getCurrentDataset().compare_runs || [];
      }

      /**
       * Get all_runs for current dataset.
       */
      function getAllRunsData() {
        return getCurrentDataset().all_runs || {};
      }

      /* ── Shared data (dynamic references to current dataset) ── */
      let compareRuns = getCompareRuns();
      let allRunsData = getAllRunsData();

      /**
       * Refresh data references when dataset changes.
       */
      function refreshDataReferences() {
        compareRuns = getCompareRuns();
        allRunsData = getAllRunsData();
        console.log('[Dataset] Refreshed data - compareRuns:', compareRuns.length, 'allRunsData keys:', Object.keys(allRunsData).length);
      }

      /**
       * Initialize dataset selector if multiple datasets available.
       */
      function initDatasetSelector() {
        if (!hasMultipleDatasets) {
          console.log('[Dataset] Single dataset mode');
          return;
        }

        const container = document.getElementById('dataset-selector-container');
        const select = document.getElementById('dataset-select');

        if (!container || !select) return;

        container.style.display = 'flex';

        // Populate options
        for (const [key, dataset] of Object.entries(report.datasets)) {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = dataset.label;
          if (key === currentDatasetKey) option.selected = true;
          select.appendChild(option);
        }

        // Handle change
        select.addEventListener('change', (e) => {
          currentDatasetKey = e.target.value;
          console.log('[Dataset Switch] Switching to:', currentDatasetKey);
          rerenderAllSections();
        });

        console.log('[Dataset] Multi-dataset mode initialized with', Object.keys(report.datasets).length, 'datasets');
      }

      /**
       * Re-render all sections when dataset changes.
       */
      function rerenderAllSections() {
        // Refresh data references
        refreshDataReferences();

        // Destroy all existing chart instances
        destroyAllCharts();

        // Re-render each section
        renderExecutiveSummary();
        buildDeepDiveRunOptions();
        renderDeepDive();
        initRunComparison();
        initModelComparison();
        renderItemComparison();
        renderFailures();
        
        // Reset query details selection for dataset change
        if (typeof resetQueryDetails === 'function') {
          resetQueryDetails();
        }
      }

      // Chart instance registry for cleanup
      const chartRegistry = {};

      function registerChart(id, chart) {
        if (chartRegistry[id]) {
          chartRegistry[id].destroy();
        }
        chartRegistry[id] = chart;
        return chart;
      }

      function destroyAllCharts() {
        for (const [id, chart] of Object.entries(chartRegistry)) {
          if (chart) {
            chart.destroy();
            delete chartRegistry[id];
          }
        }
        // Also destroy module-level chart instances
        if (typeof metricChartInst !== 'undefined' && metricChartInst) {
          metricChartInst.destroy();
          metricChartInst = null;
        }
        if (typeof modelMetricChartInst !== 'undefined' && modelMetricChartInst) {
          modelMetricChartInst.destroy();
          modelMetricChartInst = null;
        }
        if (typeof iterationMetricsChart !== 'undefined' && iterationMetricsChart) {
          iterationMetricsChart.destroy();
          iterationMetricsChart = null;
        }
        if (typeof iterationToolContributionChart !== 'undefined' && iterationToolContributionChart) {
          iterationToolContributionChart.destroy();
          iterationToolContributionChart = null;
        }
        if (typeof iterationToolCallsChart !== 'undefined' && iterationToolCallsChart) {
          iterationToolCallsChart.destroy();
          iterationToolCallsChart = null;
        }
        if (typeof iterationDistributionChart !== 'undefined' && iterationDistributionChart) {
          iterationDistributionChart.destroy();
          iterationDistributionChart = null;
        }
        if (typeof stratBarChart !== 'undefined' && stratBarChart) {
          stratBarChart.destroy();
          stratBarChart = null;
        }
        if (typeof stratCountChart !== 'undefined' && stratCountChart) {
          stratCountChart.destroy();
          stratCountChart = null;
        }
        if (typeof errorCategoryChart !== 'undefined' && errorCategoryChart) {
          errorCategoryChart.destroy();
          errorCategoryChart = null;
        }
        if (typeof errorByToolChart !== 'undefined' && errorByToolChart) {
          errorByToolChart.destroy();
          errorByToolChart = null;
        }
      }
      
      // Debug: Log available data on load
      console.log('[init] compareRuns count:', compareRuns.length);
      console.log('[init] allRunsData keys:', Object.keys(allRunsData));
      Object.entries(allRunsData).forEach(([name, data]) => {
        console.log('[init] Run:', name, '- item_rows:', data.item_rows?.length || 0);
      });

      /* ═══════════════════════════════════
       *  0. Collapsible sections
       * ═══════════════════════════════════ */
      (function initCollapseSections() {
        document.querySelectorAll('.section-header').forEach(header => {
          const targetId = header.dataset.target;
          if (!targetId) return;
          const body = document.getElementById(targetId);
          if (!body) return;
          const icon = header.querySelector('.collapse-icon');

          header.addEventListener('click', () => {
            const isCollapsed = body.classList.toggle('collapsed');
            if (icon) icon.classList.toggle('rotated', isCollapsed);
          });
        });
        
        // Subsection collapsible toggles (for collapsed-by-default sections)
        document.querySelectorAll('.subsection-header').forEach(header => {
          const targetId = header.dataset.target;
          if (!targetId) return;
          const body = document.getElementById(targetId);
          if (!body) return;
          const icon = header.querySelector('.collapse-icon');
          
          // Set initial state (collapsed)
          if (body.classList.contains('collapsed')) {
            if (icon) icon.classList.add('rotated');
          }

          header.addEventListener('click', () => {
            const isCollapsed = body.classList.contains('collapsed');
            if (isCollapsed) {
              // Expand
              body.style.maxHeight = body.scrollHeight + 'px';
              body.style.opacity = '1';
              body.classList.remove('collapsed');
              if (icon) icon.classList.remove('rotated');
              // Reset max-height after transition to allow dynamic content
              setTimeout(() => { body.style.maxHeight = 'none'; }, 300);
            } else {
              // Collapse
              body.style.maxHeight = body.scrollHeight + 'px';
              requestAnimationFrame(() => {
                body.style.maxHeight = '0';
                body.style.opacity = '0';
                body.classList.add('collapsed');
                if (icon) icon.classList.add('rotated');
              });
            }
          });
        });
      })();

      /* ═══════════════════════════════════
       *  0b. Navigation scroll tracking & responsive sidebar
       * ═══════════════════════════════════ */
      (function initNavTracking() {
        const navLinks = document.querySelectorAll('.nav-sidebar a');
        const navSidebar = document.getElementById('nav-sidebar');
        const sections = Array.from(navLinks).map(a => {
          const id = a.getAttribute('data-section');
          return { link: a, el: document.getElementById(id) };
        }).filter(s => s.el);

        function updateActive() {
          let current = sections[0];
          const scrollY = window.scrollY + 100;
          for (const s of sections) {
            if (s.el.offsetTop <= scrollY) current = s;
          }
          navLinks.forEach(a => a.classList.remove('active'));
          if (current) current.link.classList.add('active');
        }

        window.addEventListener('scroll', updateActive, { passive: true });
        updateActive();
        
        // Responsive sidebar: position next to main content and collapse when needed
        function updateSidebarState() {
          if (window.innerWidth <= 900) return; // Bottom bar handles this via CSS
          
          const mainContent = document.querySelector('main');
          if (!mainContent) return;
          
          // Calculate available space on the left of main content
          const mainRect = mainContent.getBoundingClientRect();
          const availableLeft = mainRect.left;
          
          // Gap between nav and main content
          const gap = 12;
          
          // Expanded nav needs ~160px, collapsed needs ~60px
          const expandedWidth = 155;
          const collapsedWidth = 55;
          
          if (availableLeft >= expandedWidth + gap) {
            // Expanded: position right next to main content
            navSidebar.classList.remove('collapsed');
            navSidebar.classList.add('expanded');
            navSidebar.style.left = (mainRect.left - expandedWidth - gap) + 'px';
          } else if (availableLeft >= collapsedWidth + gap) {
            // Collapsed: position right next to main content
            navSidebar.classList.remove('expanded');
            navSidebar.classList.add('collapsed');
            navSidebar.style.left = (mainRect.left - collapsedWidth - gap) + 'px';
          } else {
            // Very little space: stick to left edge
            navSidebar.classList.remove('expanded');
            navSidebar.classList.add('collapsed');
            navSidebar.style.left = '8px';
          }
        }
        
        window.addEventListener('resize', updateSidebarState, { passive: true });
        // Run after a short delay to ensure layout is complete
        setTimeout(updateSidebarState, 100);
        updateSidebarState();
      })();

      /* ═══════════════════════════════════
       *  1. Executive Summary
       * ═══════════════════════════════════ */
      function renderExecutiveSummary() {
        const grid = document.getElementById('exec-grid');
        const findings = document.getElementById('exec-findings');
        const legendContainer = document.getElementById('color-legend-container');
        const runs = compareRuns;
        const allRuns = allRunsData;

        // Clear existing content
        grid.innerHTML = '';
        findings.innerHTML = '';

        if (runs.length === 0) {
          grid.innerHTML = '<p class="muted">No comparison runs available.</p>';
          return;
        }

        // Add color legend
        legendContainer.innerHTML = generateColorLegend();

        // Group runs
        function groupRunsExec(runs) {
          const groupMap = {};
          const groupOrder = [];
          runs.forEach(r => {
            const match = r.run_name.match(/^(.+)-rep-\d+$/);
            const groupName = match ? match[1] : r.run_name;
            if (!groupMap[groupName]) {
              groupMap[groupName] = { groupName, runs: [] };
              groupOrder.push(groupName);
            }
            groupMap[groupName].runs.push(r);
          });
          // Sort group order by agent type then model family
          groupOrder.sort(compareRunNames);
          return groupOrder.map(g => groupMap[g]);
        }

        const groups = groupRunsExec(runs);

        // Find best group by avg_f1 (or first available metric)
        const metricKey = Object.keys(runs[0]?.metrics || {}).find(k => k.includes('f1')) ||
                          Object.keys(runs[0]?.metrics || {})[0] || '';

        let bestGroup = null;
        let bestScore = -Infinity;
        let worstGroup = null;
        let worstScore = Infinity;
        let fastestGroup = null;
        let fastestLatency = Infinity;
        let totalItems = 0;
        let totalFailures = 0;

        groups.forEach(g => {
          const scores = g.runs.map(r => r.metrics?.[metricKey] ?? 0);
          const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
          const latencies = g.runs.map(r => r.latency?.avg ?? Infinity);
          const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;

          totalItems += g.runs[0]?.items ?? 0;
          totalFailures += g.runs.reduce((s, r) => s + (r.failures ?? 0), 0);

          if (avgScore > bestScore) { bestScore = avgScore; bestGroup = g; }
          if (avgScore < worstScore) { worstScore = avgScore; worstGroup = g; }
          if (avgLatency < fastestLatency) { fastestLatency = avgLatency; fastestGroup = g; }
        });

        // Build executive cards
        const metricLabel = metricKey.replace(/^avg_/, '').toUpperCase();

        function badgeFor(score) {
          if (score >= 0.7) return '<span class="badge badge-success">GOOD</span>';
          if (score >= 0.4) return '<span class="badge badge-warn">MODERATE</span>';
          return '<span class="badge badge-danger">LOW</span>';
        }

        function groupChips(groupName, large = false) {
          const agentType = parseAgentType(groupName);
          const modelName = extractModelName(groupName);
          const modelFamily = parseModelFamily(modelName);
          const compact = !large;
          return '<div style="display:flex;flex-wrap:wrap;gap:4px;' + (large ? 'margin-top:4px;' : '') + '">' + 
                 createAgentChip(agentType, compact) + ' ' + 
                 createModelChip(modelFamily, modelName, compact) + 
                 '</div>';
        }

        let cardsHtml = '';

        cardsHtml += '<div class="exec-card">' +
          '<span class="exec-label">Configurations Tested</span>' +
          '<span class="exec-value">' + groups.length + '</span>' +
          '<span class="exec-detail">' + runs.length + ' total runs (' + groups.filter(g => g.runs.length > 1).length + ' with repeats)</span>' +
          '</div>';

        cardsHtml += '<div class="exec-card">' +
          '<span class="exec-label">Items per Run</span>' +
          '<span class="exec-value">' + (runs[0]?.items ?? '-') + '</span>' +
          '<span class="exec-detail">Total failures across all runs: ' + totalFailures + '</span>' +
          '</div>';

        if (bestGroup) {
          cardsHtml += '<div class="exec-card">' +
            '<span class="exec-label">Best ' + metricLabel + ' ' + badgeFor(bestScore) + '</span>' +
            '<div class="exec-value">' + groupChips(bestGroup.groupName, true) + '</div>' +
            '<span class="exec-detail">Score: ' + fmt(bestScore, 4) + '</span>' +
            '</div>';
        }

        if (worstGroup && groups.length > 1) {
          cardsHtml += '<div class="exec-card">' +
            '<span class="exec-label">Lowest ' + metricLabel + ' ' + badgeFor(worstScore) + '</span>' +
            '<div class="exec-value">' + groupChips(worstGroup.groupName, true) + '</div>' +
            '<span class="exec-detail">Score: ' + fmt(worstScore, 4) + '</span>' +
            '</div>';
        }

        if (fastestGroup) {
          cardsHtml += '<div class="exec-card">' +
            '<span class="exec-label">Fastest (Avg Latency)</span>' +
            '<div class="exec-value">' + groupChips(fastestGroup.groupName, true) + '</div>' +
            '<span class="exec-detail">' + fmt(fastestLatency, 1) + 's average</span>' +
            '</div>';
        }

        // Score range card
        if (groups.length > 1) {
          cardsHtml += '<div class="exec-card">' +
            '<span class="exec-label">' + metricLabel + ' Range</span>' +
            '<span class="exec-value">' + fmt(worstScore, 3) + ' &mdash; ' + fmt(bestScore, 3) + '</span>' +
            '<span class="exec-detail">Spread: ' + fmt(bestScore - worstScore, 3) + '</span>' +
            '</div>';
        }

        grid.innerHTML = cardsHtml;

        // Build findings summary with chips
        let findingsHtml = '<div style="margin-top:12px;padding:12px 16px;border-radius:var(--radius-md);background:var(--pre-bg);">';
        findingsHtml += '<h3 style="margin:0 0 8px;">Key Findings</h3><ul style="margin:0;padding-left:20px;color:var(--text);font-size:0.9rem;line-height:1.8;">';

        if (bestGroup) {
          const agentType = parseAgentType(bestGroup.groupName);
          const modelName = extractModelName(bestGroup.groupName);
          const modelFamily = parseModelFamily(modelName);
          findingsHtml += '<li>' + createAgentChip(agentType, true) + ' ' + createModelChip(modelFamily, modelName, true) + 
            ' achieves the highest ' + metricLabel + ' at <strong>' + fmt(bestScore, 4) + '</strong>.';
          if (bestGroup.runs.length > 1) {
            const scores = bestGroup.runs.map(r => r.metrics?.[metricKey] ?? 0);
            const sd = summarize(scores).sd;
            findingsHtml += ' (across ' + bestGroup.runs.length + ' reps, SD=' + fmt(sd, 4) + ')';
          }
          findingsHtml += '</li>';
        }

        if (fastestGroup && fastestGroup !== bestGroup) {
          const agentType = parseAgentType(fastestGroup.groupName);
          const modelName = extractModelName(fastestGroup.groupName);
          const modelFamily = parseModelFamily(modelName);
          findingsHtml += '<li>' + createAgentChip(agentType, true) + ' ' + createModelChip(modelFamily, modelName, true) + 
            ' is the fastest configuration at <strong>' + fmt(fastestLatency, 1) + 's</strong> average latency.</li>';
        }

        // Check failure rate
        const failureGroups = groups.filter(g => g.runs.some(r => (r.failures ?? 0) > 0));
        if (failureGroups.length > 0) {
          findingsHtml += '<li>' + failureGroups.length + ' of ' + groups.length + ' configuration(s) had failures.</li>';
        } else {
          findingsHtml += '<li>No failures across any configuration.</li>';
        }

        // Model diversity with chips
        const modelFamilies = new Set();
        const agentTypes = new Set();
        runs.forEach(r => {
          const model = r.run_metadata?.model || r.run_metadata?.llm_model || r.run_name;
          modelFamilies.add(parseModelFamily(model));
          agentTypes.add(parseAgentType(r.run_name));
        });
        
        if (modelFamilies.size > 1 || agentTypes.size > 1) {
          findingsHtml += '<li>Tested configurations: ';
          const chips = [];
          agentTypes.forEach(at => chips.push(createAgentChip(at, true)));
          modelFamilies.forEach(mf => { if (mf !== 'other') chips.push(createModelChip(mf, null, true)); });
          findingsHtml += chips.join(' ') + '</li>';
        }

        findingsHtml += '</ul></div>';
        findings.innerHTML = findingsHtml;
      }
      // Initial render
      renderExecutiveSummary();

      /* ═══════════════════════════════════
       *  2. Deep Dive Section
       * ═══════════════════════════════════ */
      const elDeepDiveRun = document.getElementById('deepdive-run');
      const elBaselineRun = document.getElementById('baseline-run');
      const elIterationFilter = document.getElementById('iteration-filter');
      
      // Chart instances for cleanup
      let iterationMetricsChart = null;
      let iterationToolContributionChart = null;
      let iterationToolCallsChart = null;

      // Tool display name mapping (used across Deep Dive)
      const TOOL_DISPLAY_NAMES = {
        'search_entities_tool': 'Search',
        'execute_sql_query_tool': 'SQL',
        'execute_sparql_query_tool': 'SPARQL',
      };

      function getToolDisplayName(toolName) {
        return TOOL_DISPLAY_NAMES[toolName] || toolName.replace('_tool', '').replace(/_/g, ' ');
      }

      function getToolColor(toolName) {
        return TOOL_COLORS[toolName] || COLORS.gray;
      }

      /**
       * Group all_runs keys by stripping '-rep-{N}' suffix.
       * Groups are sorted by agent type then model family.
       */
      function groupAllRuns() {
        const groupMap = {};
        const groupOrder = [];
        Object.keys(allRunsData).forEach(name => {
          const match = name.match(/^(.+)-rep-\d+$/);
          const gn = match ? match[1] : name;
          if (!groupMap[gn]) { groupMap[gn] = []; groupOrder.push(gn); }
          groupMap[gn].push(name);
        });
        // Sort group order by agent type then model family
        groupOrder.sort(compareRunNames);
        return { groupMap, groupOrder };
      }

      function buildDeepDiveRunOptions() {
        const { groupMap, groupOrder } = groupAllRuns();
        if (groupOrder.length === 0) {
          elDeepDiveRun.innerHTML = '<option value="">No runs available</option>';
          return;
        }
        const primaryRaw = report.primary_run || '';
        const primaryMatch = primaryRaw.match(/^(.+)-rep-\d+$/);
        const primaryGroup = primaryMatch ? primaryMatch[1] : primaryRaw;
        const defaultGroup = groupOrder.includes(primaryGroup) ? primaryGroup : groupOrder[0];
        elDeepDiveRun.innerHTML = groupOrder
          .map(g => {
            const n = groupMap[g].length;
            const agentType = parseAgentType(g);
            const modelName = extractModelName(g);
            const agentLabel = AGENT_COLORS[agentType]?.name || 'Auto';
            const repsLabel = n > 1 ? ' (' + n + ' reps)' : '';
            const label = agentLabel + ' + ' + modelName + repsLabel;
            return '<option value="' + escapeHtml(g) + '"' + (g === defaultGroup ? ' selected' : '') + '>' + escapeHtml(label) + '</option>';
          })
          .join('');
        console.log('[buildDeepDiveRunOptions] Built options for groups:', groupOrder);
      }

      /**
       * Build baseline run dropdown options (excluding currently selected run).
       */
      function buildBaselineRunOptions(excludeGroup) {
        const { groupMap, groupOrder } = groupAllRuns();
        if (!elBaselineRun) return;
        
        let html = '<option value="">None (no comparison)</option>';
        groupOrder.forEach(g => {
          if (g === excludeGroup) return; // Don't include current run as baseline option
          const n = groupMap[g].length;
          const agentType = parseAgentType(g);
          const modelName = extractModelName(g);
          const agentLabel = AGENT_COLORS[agentType]?.name || 'Auto';
          const repsLabel = n > 1 ? ' (' + n + ' reps)' : '';
          const label = agentLabel + ' + ' + modelName + repsLabel;
          html += '<option value="' + escapeHtml(g) + '">' + escapeHtml(label) + '</option>';
        });
        elBaselineRun.innerHTML = html;
      }

      /**
       * Compute percentile from sorted array
       */
      function percentile(arr, p) {
        if (arr.length === 0) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const idx = (p / 100) * (sorted.length - 1);
        const lower = Math.floor(idx);
        const upper = Math.ceil(idx);
        if (lower === upper) return sorted[lower];
        return sorted[lower] + (sorted[upper] - sorted[lower]) * (idx - lower);
      }

      /**
       * Compute aggregated metrics for a run group.
       * Returns an object with all computed metrics.
       */
      function computeRunGroupMetrics(groupName) {
        const { groupMap } = groupAllRuns();
        const runNames = groupMap[groupName] || [];
        
        const result = {
          totalItems: 0,
          totalFailures: 0,
          totalToolCalls: 0,
          totalErrors: 0,
          totalToolCallsForErrors: 0,
          totalZeroResults: 0,
          totalQueriesForZero: 0,
          totalGoldFound: 0,
          totalFoundButNotReturned: 0,
          itemsWithMissedOpportunity: 0,
          f1Values: [],
          recallValues: [],
          precisionValues: [],
          toolPrecisionValues: [],
          toolRecallValues: [],
          latencyValues: [],
          missedOpportunityRates: [],
          iterationValues: [],
        };
        
        if (runNames.length === 0) return result;

        runNames.forEach(rn => {
          const rd = allRunsData[rn];
          if (rd?.item_rows) {
            rd.item_rows.forEach(row => {
              result.totalItems++;
              if (row.failed) {
                result.totalFailures++;
                return;
              }
              
              // Core metrics
              result.totalToolCalls += row.tool_calls_total || 0;
              if (row.metrics?.f1 != null) result.f1Values.push(row.metrics.f1);
              if (row.metrics?.recall != null) result.recallValues.push(row.metrics.recall);
              if (row.metrics?.precision != null) result.precisionValues.push(row.metrics.precision);
              if (row.latency_s != null) result.latencyValues.push(row.latency_s);
              
              // Tool effectiveness from gt_discovery
              const gtd = row.gt_discovery || {};
              if (gtd.tool_precision != null) result.toolPrecisionValues.push(gtd.tool_precision);
              if (gtd.coverage != null) result.toolRecallValues.push(gtd.coverage);
              
              // Missed opportunity metrics
              const foundIds = (gtd.found_ids || []).length;
              const foundButNotReturned = (gtd.found_but_not_returned || []).length;
              result.totalGoldFound += foundIds;
              result.totalFoundButNotReturned += foundButNotReturned;
              if (foundButNotReturned > 0) result.itemsWithMissedOpportunity++;
              if (gtd.missed_opportunity_rate != null) {
                result.missedOpportunityRates.push(gtd.missed_opportunity_rate);
              }
              
              // Iteration count - get max iteration from recall progression
              const recallProg = gtd.recall_by_call_index || [];
              if (recallProg.length > 0) {
                const maxIter = recallProg[recallProg.length - 1][0];
                result.iterationValues.push(maxIter);
              }
              
              // Error metrics
              const errorStats = row.tool_error_stats || {};
              result.totalErrors += errorStats.error_count || 0;
              result.totalToolCallsForErrors += errorStats.total_calls || 0;
              
              // Zero result metrics
              const zeroStats = row.zero_result_stats || {};
              result.totalZeroResults += zeroStats.zero_result_queries || 0;
              result.totalQueriesForZero += zeroStats.total_queries || 0;
            });
          }
        });
        
        return result;
      }
      
      /**
       * Compute derived metrics from raw aggregates.
       */
      function computeDerivedMetrics(raw) {
        const avg = arr => arr.length > 0 ? arr.reduce((s, v) => s + v, 0) / arr.length : 0;
        const successfulItems = raw.totalItems - raw.totalFailures;
        
        return {
          avgF1: avg(raw.f1Values),
          avgRecall: avg(raw.recallValues),
          avgPrecision: avg(raw.precisionValues),
          avgToolPrecision: avg(raw.toolPrecisionValues),
          avgToolRecall: avg(raw.toolRecallValues),
          avgLatency: avg(raw.latencyValues),
          p50Latency: percentile(raw.latencyValues, 50),
          p90Latency: percentile(raw.latencyValues, 90),
          avgToolCalls: successfulItems > 0 ? raw.totalToolCalls / successfulItems : 0,
          errorRate: raw.totalToolCallsForErrors > 0 ? raw.totalErrors / raw.totalToolCallsForErrors : 0,
          zeroResultRate: raw.totalQueriesForZero > 0 ? raw.totalZeroResults / raw.totalQueriesForZero : 0,
          missedOpportunityRate: raw.totalGoldFound > 0 ? raw.totalFoundButNotReturned / raw.totalGoldFound : 0,
          avgIterations: avg(raw.iterationValues),
          maxIterations: raw.iterationValues.length > 0 ? Math.max(...raw.iterationValues) : 0,
          minIterations: raw.iterationValues.length > 0 ? Math.min(...raw.iterationValues) : 0,
          // Keep raw values for details
          totalFoundButNotReturned: raw.totalFoundButNotReturned,
          itemsWithMissedOpportunity: raw.itemsWithMissedOpportunity,
          totalErrors: raw.totalErrors,
          totalToolCallsForErrors: raw.totalToolCallsForErrors,
          totalZeroResults: raw.totalZeroResults,
          totalQueriesForZero: raw.totalQueriesForZero,
        };
      }

      /**
       * Render comprehensive metrics table for the selected run group.
       * @param {string} groupName - The run group to display
       * @param {string|null} baselineGroupName - Optional baseline run group for comparison
       */
      function renderMetricsOverviewTable(groupName, baselineGroupName = null) {
        const table = document.getElementById('deepdive-metrics-table');
        const baselineNote = document.getElementById('baseline-note');
        const { groupMap } = groupAllRuns();
        const runNames = groupMap[groupName] || [];
        
        if (runNames.length === 0) {
          table.innerHTML = '<tbody><tr><td style="color:var(--muted)">No data available.</td></tr></tbody>';
          if (baselineNote) baselineNote.textContent = '';
          return;
        }

        // Compute metrics for main run
        const rawMetrics = computeRunGroupMetrics(groupName);
        const metrics = computeDerivedMetrics(rawMetrics);
        
        // Compute baseline metrics if provided
        let baselineMetrics = null;
        if (baselineGroupName && groupMap[baselineGroupName]) {
          const baselineRaw = computeRunGroupMetrics(baselineGroupName);
          baselineMetrics = computeDerivedMetrics(baselineRaw);
          if (baselineNote) {
            baselineNote.textContent = 'Values colored relative to baseline (green = better, red = worse)';
          }
        } else {
          if (baselineNote) baselineNote.textContent = '';
        }

        /**
         * Format a comparison delta string.
         * @param {number} value - Current value
         * @param {number|null} baselineValue - Baseline value (null if no baseline)
         * @param {boolean} isPercentage - Whether to format as percentage
         * @returns {string} Delta string like "+5.2%" or "-1.3s"
         */
        function formatDelta(value, baselineValue, isPercentage = true, suffix = '') {
          if (baselineValue === null || baselineValue === undefined) return '';
          
          const diff = value - baselineValue;
          if (Math.abs(diff) < 0.0001) return ''; // Too small to show
          
          const sign = diff > 0 ? '+' : '';
          if (isPercentage) {
            return ' (' + sign + (diff * 100).toFixed(1) + '%)';
          }
          return ' (' + sign + diff.toFixed(1) + suffix + ')';
        }
        
        // Get baseline values (or null if no baseline)
        const bl = baselineMetrics;
        const hasBaseline = bl !== null;
        
        // Default color when no baseline is selected
        const defaultColor = 'var(--accent)';
        
        /**
         * Get color for a metric value.
         * When baseline is selected: green for better, red for worse.
         * When no baseline: use default accent color.
         */
        function getMetricColor(value, baselineValue, higherIsBetter) {
          if (!hasBaseline) return defaultColor;
          
          const diff = value - baselineValue;
          const threshold = Math.abs(baselineValue) * 0.01; // 1% threshold for "same"
          
          if (Math.abs(diff) < threshold) {
            return 'var(--text)'; // Essentially the same - neutral color
          }
          
          const isBetter = higherIsBetter ? diff > 0 : diff < 0;
          return isBetter ? 'var(--badge-success-text)' : 'var(--badge-danger-text)';
        }
        
        // Build table HTML - grouped same as METRIC_GROUPS
        let html = '<thead><tr><th style="width:200px;">Metric</th><th style="width:150px;">Value</th><th>Details</th></tr></thead><tbody>';
        
        // Agent Effectiveness section (matches METRIC_GROUPS)
        html += '<tr><td colspan="3" class="metric-category">Agent Effectiveness</td></tr>';
        
        const f1Color = getMetricColor(metrics.avgF1, bl?.avgF1, true);
        const f1Delta = formatDelta(metrics.avgF1, bl?.avgF1, true);
        html += '<tr><td class="metric-name">F1 Score</td><td class="metric-value" style="color:' + f1Color + ';">' + (metrics.avgF1 * 100).toFixed(1) + '%' + f1Delta + '</td><td class="metric-detail">Harmonic mean of precision and recall</td></tr>';
        
        const precColor = getMetricColor(metrics.avgPrecision, bl?.avgPrecision, true);
        const precDelta = formatDelta(metrics.avgPrecision, bl?.avgPrecision, true);
        html += '<tr><td class="metric-name">Precision</td><td class="metric-value" style="color:' + precColor + ';">' + (metrics.avgPrecision * 100).toFixed(1) + '%' + precDelta + '</td><td class="metric-detail">Correct IDs / Returned IDs</td></tr>';
        
        const recallColor = getMetricColor(metrics.avgRecall, bl?.avgRecall, true);
        const recallDelta = formatDelta(metrics.avgRecall, bl?.avgRecall, true);
        html += '<tr><td class="metric-name">Recall</td><td class="metric-value" style="color:' + recallColor + ';">' + (metrics.avgRecall * 100).toFixed(1) + '%' + recallDelta + '</td><td class="metric-detail">Correct IDs / Gold IDs</td></tr>';
        
        const missedColor = getMetricColor(metrics.missedOpportunityRate, bl?.missedOpportunityRate, false);
        const missedDelta = formatDelta(metrics.missedOpportunityRate, bl?.missedOpportunityRate, true);
        html += '<tr><td class="metric-name">Missed Opportunity</td><td class="metric-value" style="color:' + missedColor + ';">' + (metrics.missedOpportunityRate * 100).toFixed(1) + '%' + missedDelta + '</td><td class="metric-detail">' + metrics.totalFoundButNotReturned + ' gold IDs found but not returned (' + metrics.itemsWithMissedOpportunity + ' items)</td></tr>';
        
        // Agent Efficiency section (matches METRIC_GROUPS)
        html += '<tr><td colspan="3" class="metric-category">Agent Efficiency</td></tr>';
        
        const latColor = getMetricColor(metrics.avgLatency, bl?.avgLatency, false);
        const latDelta = formatDelta(metrics.avgLatency, bl?.avgLatency, false, 's');
        html += '<tr><td class="metric-name">Avg Latency</td><td class="metric-value" style="color:' + latColor + ';">' + metrics.avgLatency.toFixed(1) + 's' + latDelta + '</td><td class="metric-detail">p50: ' + metrics.p50Latency.toFixed(1) + 's, p90: ' + metrics.p90Latency.toFixed(1) + 's</td></tr>';
        
        const toolCallsColor = getMetricColor(metrics.avgToolCalls, bl?.avgToolCalls, false);
        const toolCallsDelta = formatDelta(metrics.avgToolCalls, bl?.avgToolCalls, false, '');
        html += '<tr><td class="metric-name">Avg Tool Calls</td><td class="metric-value" style="color:' + toolCallsColor + ';">' + metrics.avgToolCalls.toFixed(1) + toolCallsDelta + '</td><td class="metric-detail">Tool invocations per item</td></tr>';
        
        const iterColor = getMetricColor(metrics.avgIterations, bl?.avgIterations, false);
        const iterDelta = formatDelta(metrics.avgIterations, bl?.avgIterations, false, '');
        html += '<tr><td class="metric-name">Avg Iterations</td><td class="metric-value" style="color:' + iterColor + ';">' + metrics.avgIterations.toFixed(1) + iterDelta + '</td><td class="metric-detail">Per item (min: ' + metrics.minIterations + ', max: ' + metrics.maxIterations + ')</td></tr>';
        
        // Tool Effectiveness section (matches METRIC_GROUPS)
        html += '<tr><td colspan="3" class="metric-category">Tool Effectiveness</td></tr>';
        
        const toolPrecColor = getMetricColor(metrics.avgToolPrecision, bl?.avgToolPrecision, true);
        const toolPrecDelta = formatDelta(metrics.avgToolPrecision, bl?.avgToolPrecision, true);
        html += '<tr><td class="metric-name">Tool Precision</td><td class="metric-value" style="color:' + toolPrecColor + ';">' + (metrics.avgToolPrecision * 100).toFixed(1) + '%' + toolPrecDelta + '</td><td class="metric-detail">Gold IDs found / Total IDs returned by tools</td></tr>';
        
        const toolRecColor = getMetricColor(metrics.avgToolRecall, bl?.avgToolRecall, true);
        const toolRecDelta = formatDelta(metrics.avgToolRecall, bl?.avgToolRecall, true);
        html += '<tr><td class="metric-name">Tool Recall</td><td class="metric-value" style="color:' + toolRecColor + ';">' + (metrics.avgToolRecall * 100).toFixed(1) + '%' + toolRecDelta + '</td><td class="metric-detail">Gold IDs found by tools / Total gold IDs</td></tr>';
        
        // Tool Efficiency section (matches METRIC_GROUPS)
        html += '<tr><td colspan="3" class="metric-category">Tool Efficiency</td></tr>';
        
        const errColor = getMetricColor(metrics.errorRate, bl?.errorRate, false);
        const errDelta = formatDelta(metrics.errorRate, bl?.errorRate, true);
        html += '<tr><td class="metric-name">Tool Error Rate</td><td class="metric-value" style="color:' + errColor + ';">' + (metrics.errorRate * 100).toFixed(1) + '%' + errDelta + '</td><td class="metric-detail">' + metrics.totalErrors + ' errors / ' + metrics.totalToolCallsForErrors + ' calls</td></tr>';
        
        const zeroColor = getMetricColor(metrics.zeroResultRate, bl?.zeroResultRate, false);
        const zeroDelta = formatDelta(metrics.zeroResultRate, bl?.zeroResultRate, true);
        html += '<tr><td class="metric-name">Zero Result Rate</td><td class="metric-value" style="color:' + zeroColor + ';">' + (metrics.zeroResultRate * 100).toFixed(1) + '%' + zeroDelta + '</td><td class="metric-detail">' + metrics.totalZeroResults + ' empty / ' + metrics.totalQueriesForZero + ' queries</td></tr>';
        
        html += '</tbody>';
        table.innerHTML = html;
      }

      // Store iteration data globally for filtering
      let storedIterationData = null;
      let iterationDistributionChart = null;

      /**
       * Render iteration analysis charts.
       */
      function renderIterationAnalysis(groupName) {
        const { groupMap } = groupAllRuns();
        const runNames = groupMap[groupName] || [];
        
        // Collect iteration data across all items
        const iterationData = {
          maxIteration: 0,
          itemProgressions: [], // [{iterations: [1,2,3], recall: [...], precision: [...], toolContribs: [{...}, ...], toolCallsByIter: {...}}]
          allTools: new Set(),
        };

        runNames.forEach(rn => {
          const rd = allRunsData[rn];
          if (!rd?.item_rows) return;
          
          rd.item_rows.forEach(row => {
            if (row.failed) return;
            
            // Get recall progression (which has iteration info)
            const recallProg = row.gt_discovery?.recall_by_call_index || [];
            // Get per-item tool calls by iteration (new field)
            const toolCallsByIter = row.tool_calls_by_iter || {};
            const itemMaxIter = row.max_iteration || 0;
            
            // Skip items with no iteration data
            if (recallProg.length === 0 && itemMaxIter === 0) return;
            
            const itemProg = {
              iterations: [],
              recall: [],
              precision: [],
              toolContribs: [],        // Recall contributions by tool
              precisionContribs: [],   // Precision contributions by tool
              toolCallsByIter: toolCallsByIter,  // {iteration: {tool: count}}
              maxIteration: itemMaxIter,
            };
            
            const precisionProg = row.gt_discovery?.precision_by_call_index || [];
            
            recallProg.forEach((entry, idx) => {
              const iter = entry[0];
              const recall = entry[1];
              const toolContrib = entry[2] || {};
              
              itemProg.iterations.push(iter);
              itemProg.recall.push(recall);
              itemProg.toolContribs.push(toolContrib);
              
              // Get precision and precision contributions for same iteration
              if (precisionProg[idx]) {
                itemProg.precision.push(precisionProg[idx][1]);
                itemProg.precisionContribs.push(precisionProg[idx][2] || {});
              } else {
                itemProg.precisionContribs.push({});
              }
              
              // Track tools from toolContrib (tools that found gold IDs)
              Object.keys(toolContrib).forEach(tool => {
                iterationData.allTools.add(tool);
              });
            });
            
            // Also track tools from actual tool calls (not just those finding gold)
            Object.values(toolCallsByIter).forEach(toolCounts => {
              Object.keys(toolCounts).forEach(tool => {
                iterationData.allTools.add(tool);
              });
            });
            
            // Update max iteration from both sources
            iterationData.maxIteration = Math.max(
              iterationData.maxIteration, 
              itemMaxIter,
              ...itemProg.iterations
            );
            
            iterationData.itemProgressions.push(itemProg);
          });
        });

        storedIterationData = iterationData;
        
        // Build iteration filter options
        buildIterationFilterOptions(iterationData.maxIteration);
        
        // Render charts with default filter
        updateIterationCharts();
      }

      function buildIterationFilterOptions(maxIteration) {
        if (!elIterationFilter || !storedIterationData) return;
        
        // Calculate distribution of items by iteration count
        const distribution = {};
        storedIterationData.itemProgressions.forEach(p => {
          // Use maxIteration from item (based on actual tool calls) if available
          const maxItemIter = p.maxIteration || (p.iterations.length > 0 ? Math.max(...p.iterations) : 0);
          distribution[maxItemIter] = (distribution[maxItemIter] || 0) + 1;
        });
        
        // Build filter options with item counts
        let html = '';
        for (let i = 1; i <= Math.min(maxIteration, 15); i++) {
          const count = distribution[i] || 0;
          html += '<option value="' + i + '"' + (i === 1 ? ' selected' : '') + '>' + i + ' (' + count + ' items)</option>';
        }
        elIterationFilter.innerHTML = html;
        
        // Render distribution chart
        renderIterationDistributionChart(distribution, maxIteration);
      }
      
      function renderIterationDistributionChart(distribution, maxIteration) {
        if (iterationDistributionChart) iterationDistributionChart.destroy();
        
        const canvas = document.getElementById('iteration-distribution-chart');
        if (!canvas) return;
        
        const iterations = [];
        const counts = [];
        for (let i = 1; i <= Math.min(maxIteration, 15); i++) {
          iterations.push(i);
          counts.push(distribution[i] || 0);
        }
        
        const totalItems = counts.reduce((s, v) => s + v, 0);
        
        iterationDistributionChart = new Chart(canvas.getContext('2d'), {
          type: 'bar',
          data: {
            labels: iterations.map(i => i + ' iter'),
            datasets: [{
              data: counts,
              backgroundColor: counts.map((_, idx) => {
                // Highlight the currently selected iteration
                const selected = parseInt(elIterationFilter?.value || '1', 10);
                return iterations[idx] === selected ? COLORS.accent + 'CC' : COLORS.accent + '66';
              }),
              borderColor: COLORS.accent,
              borderWidth: 1,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: (evt, elements) => {
              if (elements.length > 0) {
                const idx = elements[0].index;
                const iterValue = iterations[idx];
                if (elIterationFilter) {
                  elIterationFilter.value = iterValue;
                  updateIterationCharts();
                  // Update bar colors to highlight selection
                  iterationDistributionChart.data.datasets[0].backgroundColor = counts.map((_, i) => 
                    iterations[i] === iterValue ? COLORS.accent + 'CC' : COLORS.accent + '66'
                  );
                  iterationDistributionChart.update();
                }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const pct = totalItems > 0 ? ((ctx.raw / totalItems) * 100).toFixed(1) : 0;
                    return ctx.raw + ' items (' + pct + '%)';
                  }
                }
              }
            },
            scales: {
              x: {
                grid: { display: false },
                title: { display: true, text: 'Iterations to Complete', font: { size: 11 } }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Items', font: { size: 11 } },
                ticks: { precision: 0 }
              }
            }
          }
        });
      }

      /**
       * Helper: Get value at or before a target iteration (carry-forward logic).
       * Since recall/precision are cumulative, we use the last known value.
       * @param {number[]} iterations - Array of iteration numbers
       * @param {any[]} values - Array of values corresponding to iterations
       * @param {number} targetIter - The iteration we want the value for
       * @returns {any} The value at or before targetIter, or null if none
       */
      function getValueAtIteration(iterations, values, targetIter) {
        let lastValue = null;
        for (let i = 0; i < iterations.length; i++) {
          if (iterations[i] <= targetIter) {
            lastValue = values[i];
          } else {
            break;
          }
        }
        return lastValue;
      }

      function updateIterationCharts() {
        if (!storedIterationData) return;
        
        const exactIterations = parseInt(elIterationFilter?.value || '1', 10);
        const data = storedIterationData;
        
        // Update distribution chart highlighting
        if (iterationDistributionChart) {
          const labels = iterationDistributionChart.data.labels;
          iterationDistributionChart.data.datasets[0].backgroundColor = labels.map((_, idx) => {
            return (idx + 1) === exactIterations ? COLORS.accent + 'CC' : COLORS.accent + '66';
          });
          iterationDistributionChart.update('none');
        }
        
        // Filter items that have exactly the target number of iterations
        const filteredItems = data.itemProgressions.filter(p => {
          // Use maxIteration from item (based on actual tool calls) if available
          const maxItemIter = p.maxIteration || (p.iterations.length > 0 ? Math.max(...p.iterations) : 0);
          return maxItemIter === exactIterations;
        });
        
        // Update item count display
        const countEl = document.getElementById('iteration-item-count');
        if (countEl) {
          countEl.textContent = '(' + filteredItems.length + ' items)';
        }
        
        if (filteredItems.length === 0) {
          // Clear charts if no data
          if (iterationMetricsChart) { iterationMetricsChart.destroy(); iterationMetricsChart = null; }
          if (iterationToolContributionChart) { iterationToolContributionChart.destroy(); iterationToolContributionChart = null; }
          if (iterationToolCallsChart) { iterationToolCallsChart.destroy(); iterationToolCallsChart = null; }
          return;
        }
        
        // Determine iterations to show (1 to exactIterations selected by user)
        const iterations = [];
        for (let i = 1; i <= exactIterations; i++) iterations.push(i);
        
        // Calculate tool contributions at each iteration using carry-forward logic
        const toolNames = Array.from(data.allTools);
        
        // Recall contributions by tool
        const toolRecallContribByIter = {};
        toolNames.forEach(tool => {
          toolRecallContribByIter[tool] = iterations.map(iter => {
            const values = filteredItems
              .map(p => {
                const contrib = getValueAtIteration(p.iterations, p.toolContribs, iter);
                return contrib ? (contrib[tool] || 0) : null;
              })
              .filter(v => v !== null);
            return values.length > 0 ? values.reduce((s, v) => s + v, 0) / values.length : 0;
          });
        });
        
        // Precision contributions by tool
        const toolPrecisionContribByIter = {};
        toolNames.forEach(tool => {
          toolPrecisionContribByIter[tool] = iterations.map(iter => {
            const values = filteredItems
              .map(p => {
                const contrib = getValueAtIteration(p.iterations, p.precisionContribs, iter);
                return contrib ? (contrib[tool] || 0) : null;
              })
              .filter(v => v !== null);
            return values.length > 0 ? values.reduce((s, v) => s + v, 0) / values.length : 0;
          });
        });
        
        // Render precision contribution chart (stacked or lines based on toggle)
        const precisionStacked = document.getElementById('iteration-precision-stacked-checkbox')?.checked ?? true;
        renderPrecisionContributionChart(iterations, toolNames, toolPrecisionContribByIter, precisionStacked);
        
        // Render recall contribution stacked area chart
        renderToolContributionChart(iterations, toolNames, toolRecallContribByIter);
        
        // Render tool calls by iteration
        // For "exactly N iterations", all filtered items have the same iteration count
        const itemCount = filteredItems.length;
        const itemCountByIteration = {};
        iterations.forEach(iter => {
          itemCountByIteration[iter] = itemCount;
        });
        renderToolCallsByIterationChart(iterations, data.toolCallsByIteration, toolNames, itemCountByIteration, filteredItems);
      }

      /**
       * Render Tool Precision Contribution chart over iterations.
       * @param {Array} iterations - List of iteration numbers
       * @param {Array} toolNames - List of tool names
       * @param {Object} toolPrecisionContribByIter - {toolName: [precision at iter 1, iter 2, ...]}
       * @param {boolean} useStacked - Whether to stack areas or show as separate lines
       */
      function renderPrecisionContributionChart(iterations, toolNames, toolPrecisionContribByIter, useStacked) {
        if (iterationMetricsChart) iterationMetricsChart.destroy();
        
        const canvas = document.getElementById('iteration-metrics-chart');
        if (!canvas) return;
        
        // Update description
        const descEl = document.getElementById('iteration-precision-description');
        if (descEl) {
          descEl.textContent = useStacked
            ? 'Stacked view: Areas show cumulative precision contribution from each tool. Higher total area indicates tools are returning more relevant results overall at each iteration.'
            : 'Line view: Each line shows a tool\'s independent precision (gold found / total returned) at each iteration. Compare which tool maintains highest precision as iterations progress.';
        }
        
        // Sort tools by total contribution
        const sortedTools = [...toolNames].sort((a, b) => {
          const sumA = toolPrecisionContribByIter[a]?.reduce((s, v) => s + v, 0) || 0;
          const sumB = toolPrecisionContribByIter[b]?.reduce((s, v) => s + v, 0) || 0;
          return sumB - sumA;
        });
        
        // Build datasets - stacked areas or separate lines
        const datasets = sortedTools.map(tool => ({
          label: getToolDisplayName(tool),
          data: toolPrecisionContribByIter[tool] || iterations.map(() => 0),
          backgroundColor: useStacked ? getToolColor(tool) + 'AA' : 'transparent',
          borderColor: getToolColor(tool),
          borderWidth: useStacked ? 1 : 2,
          fill: useStacked,
          tension: 0.1,
          pointRadius: useStacked ? 0 : 3,
          pointHoverRadius: useStacked ? 4 : 5,
        }));
        
        // Calculate dynamic y-axis max
        let yMax;
        if (useStacked) {
          // For stacked: max of sums at each iteration
          const stackedMaxes = iterations.map((_, idx) => {
            return sortedTools.reduce((sum, tool) => sum + (toolPrecisionContribByIter[tool]?.[idx] || 0), 0);
          });
          const maxVal = stackedMaxes.length > 0 ? Math.max(...stackedMaxes) : 0;
          yMax = Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1);
        } else {
          // For lines: max of individual values
          const allValues = sortedTools.flatMap(tool => toolPrecisionContribByIter[tool] || []);
          const maxVal = allValues.length > 0 ? Math.max(...allValues) : 0;
          yMax = Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1);
        }
        
        iterationMetricsChart = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: {
            labels: iterations.map(i => 'Iter ' + i),
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { boxWidth: 12, padding: 12, font: { size: 11 } }
              },
              tooltip: {
                callbacks: {
                  label: ctx => ctx.dataset.label + ': ' + (ctx.raw * 100).toFixed(1) + '%'
                }
              }
            },
            scales: {
              x: {
                title: { display: true, text: 'Iteration', font: { size: 11 } },
                grid: { display: false }
              },
              y: {
                stacked: useStacked,
                beginAtZero: true,
                max: yMax,
                ticks: { callback: v => (v * 100).toFixed(0) + '%' },
                title: { display: true, text: 'Tool Precision', font: { size: 11 } }
              }
            }
          }
        });
      }

      function renderToolContributionChart(iterations, toolNames, toolContribByIter) {
        if (iterationToolContributionChart) iterationToolContributionChart.destroy();
        
        const canvas = document.getElementById('iteration-tool-contribution-chart');
        if (!canvas) return;
        
        // Sort tools by total contribution
        const sortedTools = toolNames.sort((a, b) => {
          const sumA = toolContribByIter[a].reduce((s, v) => s + v, 0);
          const sumB = toolContribByIter[b].reduce((s, v) => s + v, 0);
          return sumB - sumA;
        });
        
        const datasets = sortedTools.map(tool => ({
          label: getToolDisplayName(tool),
          data: toolContribByIter[tool],
          backgroundColor: getToolColor(tool) + 'AA',
          borderColor: getToolColor(tool),
          borderWidth: 1,
          fill: true,
        }));
        
        // Calculate dynamic y-axis max (sum of all tools at each iteration for stacked chart)
        const stackedMaxes = iterations.map((_, idx) => {
          return sortedTools.reduce((sum, tool) => sum + (toolContribByIter[tool][idx] || 0), 0);
        });
        const maxVal = stackedMaxes.length > 0 ? Math.max(...stackedMaxes) : 0;
        const yMax = Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1); // Round up to nearest 5%, cap at 100%
        
        iterationToolContributionChart = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: {
            labels: iterations.map(i => 'Iter ' + i),
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { boxWidth: 12, padding: 12, font: { size: 11 } }
              },
              tooltip: {
                callbacks: {
                  label: ctx => ctx.dataset.label + ': ' + (ctx.raw * 100).toFixed(1) + '%'
                }
              }
            },
            scales: {
              x: {
                title: { display: true, text: 'Iteration', font: { size: 11 } },
                grid: { display: false }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                max: yMax,
                ticks: { callback: v => (v * 100).toFixed(0) + '%' },
                title: { display: true, text: 'Cumulative Recall', font: { size: 11 } }
              }
            }
          }
        });
      }

      /**
       * Compute statistics for an array of numbers.
       * Filters out null/undefined/NaN values before computing.
       * Returns both 'sd' and 'std' (aliases) for backward compatibility.
       * @param {number[]} values - Array of numeric values
       * @returns {Object} Statistics object with n, mean, sd, std, min, max, p25, p50, p75, sum
       */
      function computeStats(values) {
        // Filter out invalid values
        const valid = (values || []).filter(v => v != null && !Number.isNaN(v));
        
        if (valid.length === 0) {
          return { n: 0, mean: null, sd: 0, std: 0, min: null, max: null, p25: 0, p50: 0, p75: 0, sum: 0 };
        }
        
        const n = valid.length;
        const sum = valid.reduce((s, v) => s + v, 0);
        const mean = sum / n;
        const variance = n > 1 ? valid.reduce((s, v) => s + (v - mean) ** 2, 0) / (n - 1) : 0;
        const sd = Math.sqrt(variance);
        const sorted = [...valid].sort((a, b) => a - b);
        
        const percentile = (p) => {
          const idx = (p / 100) * (n - 1);
          const lower = Math.floor(idx);
          const upper = Math.ceil(idx);
          if (lower === upper) return sorted[lower];
          return sorted[lower] * (upper - idx) + sorted[upper] * (idx - lower);
        };
        
        return {
          n,
          mean,
          sd,        // Standard deviation (sample)
          std: sd,   // Alias for backward compatibility
          min: sorted[0],
          max: sorted[n - 1],
          p25: percentile(25),
          p50: percentile(50),
          p75: percentile(75),
          sum
        };
      }

      function renderToolCallsByIterationChart(iterations, toolCallsByIter, toolNames, itemCountByIteration, filteredItems) {
        if (iterationToolCallsChart) iterationToolCallsChart.destroy();
        
        const canvas = document.getElementById('iteration-tool-calls-chart');
        if (!canvas) return;
        
        // Collect per-item tool call counts at each iteration for each tool
        // Structure: {iter: {tool: [count_item1, count_item2, ...]}}
        const perItemCallsByIter = {};
        iterations.forEach(iter => {
          perItemCallsByIter[iter] = {};
          toolNames.forEach(tool => {
            perItemCallsByIter[iter][tool] = [];
          });
        });
        
        filteredItems.forEach(p => {
          const toolCallsByIterForItem = p.toolCallsByIter || {};
          const itemMaxIter = p.maxIteration || (p.iterations.length > 0 ? Math.max(...p.iterations) : 0);
          
          // For each iteration this item reached, record tool call counts
          iterations.forEach(iter => {
            if (iter <= itemMaxIter) {
              // Item reached this iteration - record actual counts (0 if tool not used)
              const iterCounts = toolCallsByIterForItem[iter] || {};
              toolNames.forEach(tool => {
                perItemCallsByIter[iter][tool].push(iterCounts[tool] || 0);
              });
            }
          });
        });
        
        // Compute statistics for each tool at each iteration
        const statsByIter = {};  // {iter: {tool: {n, mean, sd, ...}}}
        iterations.forEach(iter => {
          statsByIter[iter] = {};
          toolNames.forEach(tool => {
            statsByIter[iter][tool] = computeStats(perItemCallsByIter[iter][tool]);
          });
        });
        
        // Sort tools by total usage across all iterations
        const sortedTools = [...toolNames].sort((a, b) => {
          let sumA = 0, sumB = 0;
          iterations.forEach(iter => {
            sumA += (statsByIter[iter]?.[a]?.sum || 0);
            sumB += (statsByIter[iter]?.[b]?.sum || 0);
          });
          return sumB - sumA;
        });
        
        // Calculate average tool calls per item at each iteration (stacked by tool)
        const datasets = sortedTools.map(tool => ({
          label: getToolDisplayName(tool),
          data: iterations.map(iter => statsByIter[iter]?.[tool]?.mean || 0),
          backgroundColor: getToolColor(tool) + 'CC',
          borderColor: getToolColor(tool),
          borderWidth: 1,
        }));
        
        // Calculate max Y value for better scaling
        let maxY = 0;
        iterations.forEach(iter => {
          let iterTotal = 0;
          sortedTools.forEach(tool => {
            iterTotal += (statsByIter[iter]?.[tool]?.mean || 0);
          });
          maxY = Math.max(maxY, iterTotal);
        });
        maxY = Math.ceil(maxY * 1.1);  // Add 10% padding
        
        iterationToolCallsChart = new Chart(canvas.getContext('2d'), {
          type: 'bar',
          data: {
            labels: iterations.map(i => 'Iter ' + i),
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { boxWidth: 12, padding: 12, font: { size: 11 } }
              },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const iter = iterations[ctx.dataIndex];
                    const tool = sortedTools[ctx.datasetIndex];
                    const stats = statsByIter[iter]?.[tool];
                    if (!stats || stats.n === 0) return ctx.dataset.label + ': no data';
                    
                    // Return multiple lines for detailed stats
                    const lines = [
                      ctx.dataset.label,
                      '  Mean: ' + stats.mean.toFixed(2) + ' ± ' + stats.sd.toFixed(2) + ' SD',
                      '  Median (p50): ' + stats.p50.toFixed(2),
                      '  Range: ' + stats.min + ' – ' + stats.max,
                      '  IQR: ' + stats.p25.toFixed(2) + ' – ' + stats.p75.toFixed(2),
                      '  Total: ' + stats.sum + ' calls / ' + stats.n + ' items',
                    ];
                    return lines;
                  }
                }
              }
            },
            scales: {
              x: {
                stacked: true,
                title: { display: true, text: 'Iteration', font: { size: 11 } },
                grid: { display: false }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                suggestedMax: maxY,
                title: { display: true, text: 'Avg Tool Calls per Item', font: { size: 11 } }
              }
            }
          }
        });
      }

      // Iteration filter change handler
      if (elIterationFilter) {
        elIterationFilter.addEventListener('change', updateIterationCharts);
      }
      
      // Iteration precision stacked toggle handler
      const elIterationPrecisionStackedCheckbox = document.getElementById('iteration-precision-stacked-checkbox');
      if (elIterationPrecisionStackedCheckbox) {
        elIterationPrecisionStackedCheckbox.addEventListener('change', updateIterationCharts);
      }

      /* ═══════════════════════════════════
       *  2d. Tool Errors Analysis (part of Deep Dive)
       * ═══════════════════════════════════ */
      let errorCategoryChart = null;
      let errorByToolChart = null;

      function renderDeepDiveToolErrors(groupName) {
        const { groupMap } = groupAllRuns();
        const runNames = groupMap[groupName] || [];
        const section = document.getElementById('tool-errors-section');
        const summaryGrid = document.getElementById('tool-errors-summary-grid');
        const errorTable = document.getElementById('detailed-errors-table');

        // Aggregate error data across all runs in the group
        const categoryCounts = {};    // {category: count}
        const toolErrorCounts = {};   // {tool_name: count}
        const errorMessages = {};     // {message: {count, category, tool}}
        let totalToolCalls = 0;
        let totalErrors = 0;
        let totalItems = 0;
        let itemsWithErrors = 0;

        runNames.forEach(rn => {
          const rd = allRunsData[rn];
          if (rd?.item_rows) {
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              totalItems++;
              
              const errorStats = row.tool_error_stats || {};
              totalToolCalls += errorStats.total_calls || 0;
              totalErrors += errorStats.error_count || 0;
              
              if ((errorStats.error_count || 0) > 0) {
                itemsWithErrors++;
              }

              // Aggregate by category
              const byCategory = errorStats.by_category || {};
              Object.entries(byCategory).forEach(([category, count]) => {
                categoryCounts[category] = (categoryCounts[category] || 0) + count;
              });

              // Aggregate by tool
              const byTool = errorStats.by_tool || {};
              Object.entries(byTool).forEach(([tool, stats]) => {
                if (stats.errors > 0) {
                  toolErrorCounts[tool] = (toolErrorCounts[tool] || 0) + stats.errors;
                }
              });

              // Aggregate error messages
              const errors = errorStats.errors || [];
              errors.forEach(err => {
                const msg = err.message || 'Unknown error';
                const key = msg.substring(0, 100); // Truncate for grouping
                if (!errorMessages[key]) {
                  errorMessages[key] = { 
                    count: 0, 
                    category: err.category || 'other',
                    tool: err.tool || 'unknown',
                    fullMessage: msg
                  };
                }
                errorMessages[key].count++;
              });
            });
          }
        });

        // Calculate metrics
        const errorRate = totalToolCalls > 0 ? (totalErrors / totalToolCalls) : 0;
        const itemErrorRate = totalItems > 0 ? (itemsWithErrors / totalItems) : 0;

        // Hide section if no errors
        if (totalErrors === 0) {
          section.style.display = 'none';
          return;
        }
        section.style.display = 'block';

        // Render summary cards
        let cardsHtml = '';
        
        cardsHtml += '<div class="exec-card">' +
          '<span class="exec-label">Total Tool Errors</span>' +
          '<span class="exec-value">' + totalErrors + '</span>' +
          '<span class="exec-detail">Out of ' + totalToolCalls + ' tool calls</span>' +
          '</div>';

        cardsHtml += '<div class="exec-card">' +
          '<span class="exec-label">Error Rate (per call)</span>' +
          '<span class="exec-value">' + (errorRate * 100).toFixed(1) + '%</span>' +
          '<span class="exec-detail">' + totalErrors + ' errors ÷ ' + totalToolCalls + ' calls</span>' +
          '</div>';

        cardsHtml += '<div class="exec-card">' +
          '<span class="exec-label">Error Rate (per item)</span>' +
          '<span class="exec-value">' + (itemErrorRate * 100).toFixed(1) + '%</span>' +
          '<span class="exec-detail">' + itemsWithErrors + ' of ' + totalItems + ' items had ≥1 error</span>' +
          '</div>';

        const numCategories = Object.keys(categoryCounts).length;
        cardsHtml += '<div class="exec-card">' +
          '<span class="exec-label">Error Categories</span>' +
          '<span class="exec-value">' + numCategories + '</span>' +
          '<span class="exec-detail">Distinct error types identified</span>' +
          '</div>';

        summaryGrid.innerHTML = cardsHtml;

        // Render error category chart
        const categoryEntries = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);
        const categoryLabels = categoryEntries.map(([cat]) => cat.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()));
        const categoryValues = categoryEntries.map(([, count]) => count);
        const categoryColors = categoryEntries.map(([cat]) => getErrorCategoryColor(cat));

        if (errorCategoryChart) errorCategoryChart.destroy();
        if (categoryLabels.length > 0) {
          errorCategoryChart = new Chart(document.getElementById('error-category-chart').getContext('2d'), {
            type: 'pie',
            data: {
              labels: categoryLabels,
              datasets: [{
                data: categoryValues,
                backgroundColor: categoryColors.map(c => c + 'cc'),
                borderColor: categoryColors,
                borderWidth: 2,
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: true,
                  position: 'right',
                  labels: { boxWidth: 12, padding: 10, font: { size: 10 } }
                },
                tooltip: {
                  callbacks: {
                    label: (ctx) => {
                      const pct = totalErrors > 0 ? ((ctx.raw / totalErrors) * 100).toFixed(1) : 0;
                      return `${ctx.label}: ${ctx.raw} (${pct}%)`;
                    }
                  }
                }
              }
            }
          });
        }

        // Render errors by tool chart
        const toolEntries = Object.entries(toolErrorCounts).sort((a, b) => b[1] - a[1]);
        const toolLabels = toolEntries.map(([tool]) => getToolDisplayName(tool));
        const toolValues = toolEntries.map(([, count]) => count);
        const toolColors = toolEntries.map(([tool]) => getToolColor(tool));

        if (errorByToolChart) errorByToolChart.destroy();
        if (toolLabels.length > 0) {
          errorByToolChart = new Chart(document.getElementById('error-by-tool-chart').getContext('2d'), {
            type: 'bar',
            data: {
              labels: toolLabels,
              datasets: [{
                data: toolValues,
                backgroundColor: toolColors.map(c => c + 'cc'),
                borderColor: toolColors,
                borderWidth: 2,
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              indexAxis: 'y',
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) => `${ctx.raw} errors`
                  }
                }
              },
              scales: {
                x: { beginAtZero: true, title: { display: true, text: 'Error Count', font: { size: 11 } } },
                y: { grid: { display: false } }
              }
            }
          });
        }

        // Render detailed errors table
        const sortedErrors = Object.entries(errorMessages)
          .sort((a, b) => b[1].count - a[1].count)
          .slice(0, 20); // Top 20 errors

        if (sortedErrors.length > 0) {
          let tableHtml = '<thead><tr>' +
            '<th>Count</th>' +
            '<th>Category</th>' +
            '<th>Tool</th>' +
            '<th>Error Message</th>' +
            '</tr></thead><tbody>';

          sortedErrors.forEach(([key, data]) => {
            const categoryBadge = '<span class="badge" style="background:' + getErrorCategoryColor(data.category) + '22;color:' + getErrorCategoryColor(data.category) + ';">' +
              data.category.replace(/_/g, ' ') + '</span>';
            const toolChip = '<span style="font-size:0.8rem;color:' + getToolColor(data.tool) + ';">' + getToolDisplayName(data.tool) + '</span>';
            
            tableHtml += '<tr>' +
              '<td style="font-weight:600;text-align:center;">' + data.count + '</td>' +
              '<td>' + categoryBadge + '</td>' +
              '<td>' + toolChip + '</td>' +
              '<td class="query-cell" style="font-size:0.85rem;" title="' + escapeHtml(data.fullMessage) + '">' + escapeHtml(data.fullMessage.substring(0, 150)) + (data.fullMessage.length > 150 ? '...' : '') + '</td>' +
              '</tr>';
          });

          tableHtml += '</tbody>';
          errorTable.innerHTML = tableHtml;
        } else {
          errorTable.innerHTML = '<tbody><tr><td style="color:var(--muted)">No detailed error messages available.</td></tr></tbody>';
        }
      }

      /* ═══════════════════════════════════
       *  3. Category Stratification (part of Deep Dive)
       * ═══════════════════════════════════ */
      const elStratDim       = document.getElementById('strat-dimension');
      const elStratMetric    = document.getElementById('strat-metric');

      let stratBarInst   = null;
      let stratCountInst = null;

      const STRAT_SORT_ORDER = {
        gold_size: ['1', '2-5', '6-20', '20+'],
        query_complexity: ['simple', 'moderate', 'complex'],
        latency_bucket: ['fast (<=30s)', 'medium (30-90s)', 'slow (>90s)', 'unknown'],
      };

      function sortCategories(dim, keys) {
        const order = STRAT_SORT_ORDER[dim];
        if (!order) return keys.sort();
        return keys.sort((a, b) => {
          const ia = order.indexOf(a);
          const ib = order.indexOf(b);
          if (ia === -1 && ib === -1) return a.localeCompare(b);
          if (ia === -1) return 1;
          if (ib === -1) return -1;
          return ia - ib;
        });
      }

      function buildStratMetricOptions() {
        const names = new Set();
        Object.values(allRunsData).forEach(rd => {
          (rd.item_rows || []).forEach(row => {
            Object.keys(row.metrics || {}).forEach(n => names.add(n));
          });
        });
        // Add computed metrics that make sense for stratification
        ['tool_error_rate', 'zero_result_rate', 'tool_usage', 'tool_precision', 'tool_recall', 'missed_opportunity_rate', 'iterations'].forEach(m => names.add(m));
        
        const preferred = ['f1', 'recall', 'precision'];
        const defaultMetric = preferred.find(p => names.has(p)) || Array.from(names)[0] || '';
        elStratMetric.innerHTML = buildGroupedMetricOptionsHTML(names, defaultMetric);
      }

      /**
       * Compute stratification data for a run group.
       * For groups with multiple reps, per-item scores are averaged across
       * reps first, then stratified by category.
       */
      function computeStratData(groupName, dimension, metric) {
        const { groupMap } = groupAllRuns();
        const runNames = groupMap[groupName] || [];
        if (runNames.length === 0) return {};

        // Collect per-item data across all reps in this group.
        // Key by item_id, accumulate metric values + categories.
        const itemMap = {}; // itemKey -> { values: [], categories, failed, count }

        runNames.forEach(runName => {
          const rd = allRunsData[runName];
          if (!rd?.item_rows) return;
          rd.item_rows.forEach(row => {
            const key = row.item_id ?? row.input ?? '';
            if (!itemMap[key]) {
              itemMap[key] = {
                values: [],
                categories: row.categories || {},
                failCount: 0,
                repCount: 0,
              };
            }
            itemMap[key].repCount++;
            if (row.failed) {
              itemMap[key].failCount++;
              return;
            }
            // Handle computed metrics from gt_discovery
            let val;
            if (metric === 'missed_opportunity_rate') {
              val = row.gt_discovery?.missed_opportunity_rate;
            } else if (metric === 'iterations') {
              // Get max iteration from recall progression
              const recallProg = row.gt_discovery?.recall_by_call_index || [];
              if (recallProg.length > 0) {
                val = recallProg[recallProg.length - 1][0];
              }
            } else {
              val = row.metrics?.[metric];
            }
            if (val !== null && val !== undefined && !Number.isNaN(val)) {
              itemMap[key].values.push(val);
            }
          });
        });

        // Now stratify the averaged per-item scores by category
        const groups = {};
        Object.values(itemMap).forEach(item => {
          const cat = item.categories[dimension] ?? 'unknown';
          if (!groups[cat]) groups[cat] = { values: [], count: 0, failures: 0 };
          groups[cat].count++;
          if (item.values.length === 0) {
            if (item.failCount > 0) groups[cat].failures++;
            return;
          }
          // Average across reps for this item
          const avg = item.values.reduce((s, v) => s + v, 0) / item.values.length;
          groups[cat].values.push(avg);
        });

        for (const g of Object.values(groups)) {
          const v = g.values;
          if (v.length === 0) {
            g.avg = 0; g.p50 = 0; g.p90 = 0; g.min = 0; g.max = 0;
            continue;
          }
          v.sort((a, b) => a - b);
          g.avg = v.reduce((s, x) => s + x, 0) / v.length;
          g.p50 = v[Math.floor(v.length * 0.5)] ?? 0;
          g.p90 = v[Math.floor(v.length * 0.9)] ?? 0;
          g.min = v[0];
          g.max = v[v.length - 1];
        }
        return groups;
      }

      // Tool-grouped metrics that should show per-tool breakdown (same as TOOL_STACKED_METRICS)
      const TOOL_GROUPED_METRICS = ['tool_error_rate', 'zero_result_rate', 'tool_usage', 'tool_precision', 'tool_recall'];
      
      // Metrics that should be displayed as percentages (0-1 scale -> 0-100%)
      const PERCENTAGE_METRICS = [
        'f1', 'recall', 'precision', 
        'avg_f1', 'avg_recall', 'avg_precision',
        'tool_precision', 'tool_recall',
        'tool_error_rate', 'zero_result_rate',
        'missed_opportunity_rate',
        'hit@1', 'hit@5', 'hit@10', 'hit@20',
        'avg_hit@1', 'avg_hit@5', 'avg_hit@10', 'avg_hit@20',
        'mrr', 'avg_mrr',
      ];
      
      /**
       * Check if a metric should be displayed as percentage.
       * First checks the explicit PERCENTAGE_METRICS list, then falls back to pattern matching
       * for unknown metrics that might contain percentage-related keywords.
       * @param {string} metric - The metric name
       * @returns {boolean} True if the metric should be displayed as a percentage
       */
      function isPercentageMetric(metric) {
        // First check explicit list
        if (PERCENTAGE_METRICS.includes(metric)) return true;
        
        // Fallback to pattern matching for unknown metrics
        const lower = metric.toLowerCase();
        return lower.includes('f1') || lower.includes('recall') || lower.includes('precision') ||
               lower.includes('accuracy') || lower.includes('coverage') || lower.includes('rate') ||
               lower.includes('exact_match') || lower.includes('hit') || lower.includes('mrr');
      }
      
      function renderStratification() {
        const groupName = elDeepDiveRun.value;  // Use deep dive run selector
        const dim       = elStratDim.value;
        const metric    = elStratMetric.value;
        if (!groupName || !dim || !metric) return;

        const agentColor = getAgentColor(parseAgentType(groupName));
        
        // Special handling for tool-grouped metrics
        if (TOOL_GROUPED_METRICS.includes(metric)) {
          renderToolGroupedMetric(groupName, metric);
          return;
        }

        const groups = computeStratData(groupName, dim, metric);
        const categories = sortCategories(dim, Object.keys(groups));
        const showAsPercentage = isPercentageMetric(metric);
        
        // Get raw values and optionally convert to percentage
        const values = categories.map(c => {
          const avg = groups[c]?.avg ?? 0;
          return showAsPercentage ? avg * 100 : avg;
        });

        if (stratBarInst) stratBarInst.destroy();
        stratBarInst = new Chart(document.getElementById('strat-bar-chart'), {
          type: 'bar',
          data: {
            labels: categories,
            datasets: [{ data: values, backgroundColor: agentColor }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { maxRotation: 60, minRotation: 30, autoSkip: true } },
              y: { 
                beginAtZero: true,
                max: showAsPercentage ? 100 : undefined,
                ticks: showAsPercentage 
                  ? { callback: v => v + '%' }
                  : { precision: 2 },
              },
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: ctx => showAsPercentage 
                    ? ctx.raw.toFixed(1) + '%'
                    : ctx.raw.toFixed(3)
                }
              }
            }
          },
        });

        if (stratCountInst) stratCountInst.destroy();
        stratCountInst = makeBarChart(
          document.getElementById('strat-count-chart'),
          categories,
          categories.map(c => groups[c]?.count ?? 0),
          COLORS.blue,
        );

        // Table removed - data shown in charts above
      }
      
      /**
       * Render tool-grouped metrics (error rate, zero result rate, tool usage) by tool.
       * Shows one bar per tool with color coding.
       */
      function renderToolGroupedMetric(groupName, metric) {
        const { groupMap } = groupAllRuns();
        const runNames = groupMap[groupName] || [];
        if (runNames.length === 0) return;
        
        const toolNames = ['search_entities_tool', 'execute_sql_query_tool', 'execute_sparql_query_tool'];
        const toolDisplayNames = toolNames.map(getToolDisplayName);
        const toolColors = toolNames.map(t => getToolColor(t));
        
        // Aggregate data by tool across all items in all reps
        const toolData = toolNames.map(toolName => {
          let totalA = 0;  // numerator (errors, zeros, or calls)
          let totalB = 0;  // denominator (total calls or queries) or item count for usage
          let itemCount = 0;
          
          runNames.forEach(runName => {
            const rd = allRunsData[runName];
            if (!rd?.item_rows) return;
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              itemCount++;
              
              if (metric === 'tool_error_rate') {
                const byTool = row.tool_error_stats?.by_tool || {};
                const stats = byTool[toolName];
                if (stats) {
                  totalA += stats.errors || 0;
                  totalB += stats.total || 0;
                }
              } else if (metric === 'zero_result_rate') {
                const byTool = row.zero_result_stats?.by_tool || {};
                const stats = byTool[toolName];
                if (stats) {
                  totalA += stats.zero || 0;
                  totalB += stats.total || 0;
                }
              } else if (metric === 'tool_usage') {
                totalA += row.tool_counts?.[toolName] || 0;
                totalB++;  // count items for averaging
              } else if (metric === 'tool_precision') {
                const gtd = row.gt_discovery || {};
                const progression = gtd.precision_by_call_index;
                if (progression && progression.length > 0) {
                  const lastEntry = progression[progression.length - 1];
                  const toolContributions = lastEntry[2] || {};
                  const toolValue = toolContributions[toolName];
                  if (toolValue !== undefined) {
                    totalA += toolValue;
                    totalB++;
                  }
                }
              } else if (metric === 'tool_recall') {
                const gtd = row.gt_discovery || {};
                const progression = gtd.recall_by_call_index;
                if (progression && progression.length > 0) {
                  const lastEntry = progression[progression.length - 1];
                  const toolContributions = lastEntry[2] || {};
                  const toolValue = toolContributions[toolName];
                  if (toolValue !== undefined) {
                    totalA += toolValue;
                    totalB++;
                  }
                }
              }
            });
          });
          
          if (metric === 'tool_usage') {
            return totalB > 0 ? totalA / totalB : 0;  // avg calls per item
          }
          return totalB > 0 ? totalA / totalB : 0;  // rate or average
        });
        
        // Count chart shows total calls by tool (or items with data for precision/recall)
        const toolCounts = toolNames.map(toolName => {
          let total = 0;
          runNames.forEach(runName => {
            const rd = allRunsData[runName];
            if (!rd?.item_rows) return;
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              if (metric === 'tool_error_rate') {
                const stats = row.tool_error_stats?.by_tool?.[toolName];
                total += stats?.total || 0;
              } else if (metric === 'zero_result_rate') {
                const stats = row.zero_result_stats?.by_tool?.[toolName];
                total += stats?.total || 0;
              } else if (metric === 'tool_usage') {
                total += row.tool_counts?.[toolName] || 0;
              } else if (metric === 'tool_precision' || metric === 'tool_recall') {
                // Count items that have data for this tool
                const gtd = row.gt_discovery || {};
                const progression = metric === 'tool_precision' 
                  ? gtd.precision_by_call_index 
                  : gtd.recall_by_call_index;
                if (progression && progression.length > 0) {
                  const lastEntry = progression[progression.length - 1];
                  const toolContributions = lastEntry[2] || {};
                  if (toolContributions[toolName] !== undefined) {
                    total++;
                  }
                }
              }
            });
          });
          return total;
        });
        
        const isPercentage = metric !== 'tool_usage';
        const yAxisLabel = metric === 'tool_usage' ? 'Avg Calls / Item' : 
                          metric === 'tool_error_rate' ? 'Error Rate' :
                          metric === 'zero_result_rate' ? 'Zero Result Rate' :
                          metric === 'tool_precision' ? 'Precision' :
                          metric === 'tool_recall' ? 'Recall' : metric;
        
        // Calculate dynamic y-axis max for percentage metrics
        const maxVal = toolData.length > 0 ? Math.max(...toolData.filter(v => v != null)) : 0;
        const yMax = isPercentage ? Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1) : undefined;
        
        if (stratBarInst) stratBarInst.destroy();
        stratBarInst = new Chart(document.getElementById('strat-bar-chart'), {
          type: 'bar',
          data: {
            labels: toolDisplayNames,
            datasets: [{
              data: toolData,
              backgroundColor: toolColors.map(c => c + 'CC'),
              borderColor: toolColors,
              borderWidth: 2,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) => isPercentage 
                    ? `${(ctx.raw * 100).toFixed(1)}%` 
                    : `${ctx.raw.toFixed(2)} calls/item`
                }
              }
            },
            scales: {
              x: { grid: { display: false } },
              y: {
                beginAtZero: true,
                max: yMax,
                ticks: isPercentage ? { callback: (v) => (v * 100).toFixed(0) + '%' } : {},
                title: { display: true, text: yAxisLabel, font: { size: 11 } }
              }
            }
          }
        });

        if (stratCountInst) stratCountInst.destroy();
        stratCountInst = new Chart(document.getElementById('strat-count-chart'), {
          type: 'bar',
          data: {
            labels: toolDisplayNames,
            datasets: [{
              data: toolCounts,
              backgroundColor: toolColors.map(c => c + '88'),
              borderColor: toolColors,
              borderWidth: 1,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) => `${ctx.raw} total calls`
                }
              }
            },
            scales: {
              x: { grid: { display: false } },
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Total Calls', font: { size: 11 } }
              }
            }
          }
        });
      }

      // Initialize stratification metric options
      (function initStratification() {
        if (Object.keys(allRunsData).length === 0) return;
        buildStratMetricOptions();
      })();

      elStratDim.addEventListener('change', renderStratification);
      elStratMetric.addEventListener('change', renderStratification);

      /* ═══════════════════════════════════
       *  Deep Dive render and init (after stratification is defined)
       * ═══════════════════════════════════ */
      function renderDeepDive() {
        const groupName = elDeepDiveRun.value;
        console.log('[renderDeepDive] Selected group:', groupName);
        if (!groupName) return;
        
        const { groupMap } = groupAllRuns();
        console.log('[renderDeepDive] Available groups:', Object.keys(groupMap));
        console.log('[renderDeepDive] Runs in selected group:', groupMap[groupName]);
        
        // Update baseline run dropdown options (exclude current run)
        buildBaselineRunOptions(groupName);
        
        // 1. Metrics Overview Table (with baseline if selected)
        try {
          const baselineGroup = elBaselineRun?.value || null;
          renderMetricsOverviewTable(groupName, baselineGroup);
          console.log('[renderDeepDive] Metrics overview rendered');
        } catch (e) {
          console.error('[renderDeepDive] Error in renderMetricsOverviewTable:', e);
        }
        
        // 2. Category Stratification
        try {
          renderStratification();
          console.log('[renderDeepDive] Stratification rendered');
        } catch (e) {
          console.error('[renderDeepDive] Error in renderStratification:', e);
        }
        
        // 3. Iteration Analysis
        try {
          renderIterationAnalysis(groupName);
          console.log('[renderDeepDive] Iteration analysis rendered');
        } catch (e) {
          console.error('[renderDeepDive] Error in renderIterationAnalysis:', e);
        }
        
        // 4. Tool Errors
        try {
          renderDeepDiveToolErrors(groupName);
          console.log('[renderDeepDive] Tool errors rendered');
        } catch (e) {
          console.error('[renderDeepDive] Error in renderDeepDiveToolErrors:', e);
        }
      }

      (function initDeepDive() {
        buildDeepDiveRunOptions();
        if (elDeepDiveRun.value) {
          renderDeepDive();
        }
      })();

      elDeepDiveRun.addEventListener('change', function(e) {
        console.log('[change event] New selection:', e.target.value);
        renderDeepDive();
      });
      
      // Baseline dropdown change handler - only re-render metrics table
      if (elBaselineRun) {
        elBaselineRun.addEventListener('change', function(e) {
          console.log('[baseline change] New baseline:', e.target.value);
          const groupName = elDeepDiveRun.value;
          const baselineGroup = e.target.value || null;
          if (groupName) {
            renderMetricsOverviewTable(groupName, baselineGroup);
          }
        });
      }

      /* ═══════════════════════════════════
       *  4. Failures (only show if there are failures)
       * ═══════════════════════════════════ */
      function renderFailures() {
        const counts = Object.entries(report.failure_error_counts || {});
        const details = report.failure_details || [];
        const failuresSection = document.getElementById('sec-failures');
        const failuresNavLink = document.querySelector('a[data-section="sec-failures"]');
        
        // Check if there are any failures across all runs
        let totalFailures = report.failures || 0;
        
        // Also check compareRuns for failures
        if (compareRuns && compareRuns.length > 0) {
          compareRuns.forEach(run => {
            const rd = allRunsData[run.run_name];
            if (rd && rd.failures) {
              totalFailures += rd.failures;
            }
          });
        }
        
        // Hide section and nav link if no failures
        if (totalFailures === 0 && counts.length === 0 && details.length === 0) {
          if (failuresSection) failuresSection.style.display = 'none';
          if (failuresNavLink) failuresNavLink.style.display = 'none';
          return;
        }
        
        // Show section if there are failures
        if (failuresSection) failuresSection.style.display = 'block';
        if (failuresNavLink) failuresNavLink.style.display = 'flex';
        
        document.getElementById('failure-counts-table').innerHTML =
          '<thead><tr><th>Error</th><th>Count</th></tr></thead><tbody>' +
          (counts.length > 0
            ? counts.map(([e, c]) => '<tr><td>' + escapeHtml(e) + '</td><td>' + c + '</td></tr>').join('')
            : '<tr><td colspan="2" style="color:var(--muted)">No failures</td></tr>') +
          '</tbody>';

        document.getElementById('failure-details-table').innerHTML =
          '<thead><tr><th>Item</th><th>Error</th></tr></thead><tbody>' +
          (details.length > 0
            ? details.map(f => '<tr><td>' + (f.item_id ?? '') + '</td><td>' + escapeHtml(f.error ?? '') + '</td></tr>').join('')
            : '<tr><td colspan="2" style="color:var(--muted)">No failures</td></tr>') +
          '</tbody>';
      }
      // Initial render
      renderFailures();

      /* ═══════════════════════════════════
       *  9. Run comparison
       * ═══════════════════════════════════ */
      const elRunsSel      = document.getElementById('compare-runs');
      const elMetricSel    = document.getElementById('compare-metric');
      // Removed: elCompTable - selected run stats table removed
      const elScoreTable   = document.getElementById('compare-score-table');
      const elItemCompareMetricSel = document.getElementById('item-compare-metric');

      /* ═══════════════════════════════════
       *  9.5 Query Details Section (declared early to avoid reference errors)
       * ═══════════════════════════════════ */
      const elQueryDetailSelect = document.getElementById('query-detail-select');
      const elQueryRunsTable = document.getElementById('query-runs-table');
      const elQueryDetailContent = document.getElementById('query-detail-content');

      // Track currently selected query and run
      let selectedQueryId = null;
      let selectedRunName = null;

      /**
       * Get item data for a specific item_id from a specific run.
       */
      function getItemFromRun(runName, itemId) {
        const rd = allRunsData[runName];
        if (!rd?.item_rows) return null;
        return rd.item_rows.find(row => String(row.item_id) === String(itemId)) || null;
      }

      /**
       * Build query selector dropdown options.
       */
      function buildQueryDetailOptions() {
        if (!elQueryDetailSelect) return;
        
        const runs = getSelectedRuns();
        if (runs.length === 0) {
          elQueryDetailSelect.innerHTML = '<option value="">No runs selected</option>';
          return;
        }
        
        // Collect unique queries from selected runs
        const queries = new Map(); // item_id -> input text
        runs.forEach(run => {
          const rd = allRunsData[run.run_name];
          if (!rd?.item_rows) return;
          rd.item_rows.forEach(row => {
            if (row.item_id && !queries.has(String(row.item_id))) {
              queries.set(String(row.item_id), row.input || '');
            }
          });
        });
        
        // Build options sorted by item_id
        const sortedIds = Array.from(queries.keys()).sort((a, b) => String(a).localeCompare(String(b)));
        let html = '<option value="">Select a query...</option>';
        sortedIds.forEach(itemId => {
          const input = queries.get(itemId);
          const truncated = input.length > 80 ? input.slice(0, 80) + '...' : input;
          const selected = itemId === selectedQueryId ? ' selected' : '';
          html += '<option value="' + escapeHtml(itemId) + '"' + selected + '>' + 
                  escapeHtml(itemId) + ': ' + escapeHtml(truncated) + '</option>';
        });
        elQueryDetailSelect.innerHTML = html;
      }

      /**
       * Format a metric value with optional std deviation.
       */
      function formatMetricWithStd(stats, isPct = false, suffix = '') {
        if (stats.mean == null) return '-';
        const val = isPct ? (stats.mean * 100).toFixed(1) + '%' : stats.mean.toFixed(1) + suffix;
        if (stats.n > 1 && stats.std != null && stats.std > 0) {
          const stdVal = isPct ? (stats.std * 100).toFixed(1) : stats.std.toFixed(1);
          return val + ' <span style="color:var(--muted);font-size:0.8em;">±' + stdVal + '</span>';
        }
        return val;
      }

      /**
       * Determine result status for a single item.
       */
      function getItemResultStatus(item) {
        if (item.failed) return 'failed';
        const predicted = item.predicted_ids || [];
        const gold = item.gold_ids || [];
        const isCorrect = predicted.length > 0 && gold.length > 0 &&
          predicted.every(id => gold.includes(id)) && 
          gold.every(id => predicted.includes(id));
        if (isCorrect) return 'correct';
        const isPartial = predicted.some(id => gold.includes(id));
        if (isPartial) return 'partial';
        return 'wrong';
      }

      /**
       * Get aggregate result status for multiple reps.
       */
      function getAggregateResultStatus(items) {
        const statuses = items.map(i => getItemResultStatus(i.item));
        const correctCount = statuses.filter(s => s === 'correct').length;
        const failedCount = statuses.filter(s => s === 'failed').length;
        const partialCount = statuses.filter(s => s === 'partial').length;
        
        if (correctCount === items.length) return { status: 'correct', label: '&#10003; All Correct' };
        if (failedCount === items.length) return { status: 'failed', label: '&#10007; All Failed' };
        if (correctCount > 0) return { status: 'mixed', label: correctCount + '/' + items.length + ' Correct' };
        if (partialCount > 0) return { status: 'partial', label: '~ Partial (' + partialCount + '/' + items.length + ')' };
        return { status: 'wrong', label: '&#10007; Wrong' };
      }

      /**
       * Render the quick comparison summary table for a query.
       */
      function renderQueryRunsSummary(itemId) {
        if (!elQueryRunsTable) return;
        
        if (!itemId) {
          elQueryRunsTable.innerHTML = '';
          return;
        }
        
        const groups = groupRuns(getSelectedRuns());
        
        let html = '<thead><tr>' +
          '<th></th><th>Run</th><th>F1</th><th>Recall</th><th>Precision</th>' +
          '<th>Latency</th><th>Iters</th><th>Result</th>' +
          '</tr></thead><tbody>';
        
        let hasAnyData = false;
        
        groups.forEach((group, groupIdx) => {
          // Collect data from all reps in this group
          const runData = [];
          group.runs.forEach(run => {
            const item = getItemFromRun(run.run_name, itemId);
            if (item) runData.push({ run, item });
          });
          
          if (runData.length === 0) return;
          hasAnyData = true;
          
          const hasMultipleReps = runData.length > 1;
          const groupId = 'query-group-' + groupIdx;
          
          // Compute aggregated stats
          const f1Stats = computeStats(runData.map(r => r.item.metrics?.f1));
          const recallStats = computeStats(runData.map(r => r.item.metrics?.recall));
          const precisionStats = computeStats(runData.map(r => r.item.metrics?.precision));
          const latencyStats = computeStats(runData.map(r => r.item.latency_s));
          const iterStats = computeStats(runData.map(r => r.item.max_iteration || 0));
          const resultStatus = getAggregateResultStatus(runData);
          
          // Determine result color
          let resultColor = 'var(--badge-danger-text)';
          if (resultStatus.status === 'correct') resultColor = 'var(--badge-success-text)';
          else if (resultStatus.status === 'partial' || resultStatus.status === 'mixed') resultColor = 'var(--badge-warn-text)';
          
          // Group header row
          const isAnySelected = runData.some(r => r.run.run_name === selectedRunName);
          html += '<tr class="query-group-header' + (isAnySelected ? ' selected-run' : '') + '" data-group="' + groupId + '">';
          
          // Expand toggle (only if multiple reps)
          if (hasMultipleReps) {
            html += '<td style="width:24px;text-align:center;cursor:pointer;" onclick="toggleQueryGroup(\'' + groupId + '\', event)">';
            html += '<span class="group-toggle" style="color:var(--muted);">&#9654;</span></td>';
          } else {
            html += '<td style="width:24px;"></td>';
          }
          
          html += '<td>' + createRunLabel(group.groupName, true);
          if (hasMultipleReps) {
            html += ' <span style="color:var(--muted);font-size:0.8em;">(' + runData.length + ' reps)</span>';
          }
          html += '</td>';
          html += '<td>' + formatMetricWithStd(f1Stats, true) + '</td>';
          html += '<td>' + formatMetricWithStd(recallStats, true) + '</td>';
          html += '<td>' + formatMetricWithStd(precisionStats, true) + '</td>';
          html += '<td>' + formatMetricWithStd(latencyStats, false, 's') + '</td>';
          html += '<td>' + formatMetricWithStd(iterStats) + '</td>';
          html += '<td style="color:' + resultColor + ';">' + resultStatus.label + '</td>';
          html += '</tr>';
          
          // Individual rep rows (hidden by default)
          if (hasMultipleReps) {
            runData.forEach((rd, repIdx) => {
              const { run, item } = rd;
              const isSelected = selectedRunName === run.run_name;
              const repStatus = getItemResultStatus(item);
              
              let repResultColor = 'var(--badge-danger-text)';
              let repResultLabel = '&#10007; Wrong';
              if (repStatus === 'correct') { repResultColor = 'var(--badge-success-text)'; repResultLabel = '&#10003; Correct'; }
              else if (repStatus === 'partial') { repResultColor = 'var(--badge-warn-text)'; repResultLabel = '~ Partial'; }
              else if (repStatus === 'failed') { repResultLabel = '&#10007; Failed'; }
              
              html += '<tr class="query-rep-row ' + groupId + (isSelected ? ' selected-run' : '') + '" ';
              html += 'data-run="' + escapeHtml(run.run_name) + '" style="display:none;">';
              html += '<td></td>';
              html += '<td style="padding-left:24px;"><span style="color:var(--muted);font-size:0.85em;">Rep ' + (repIdx + 1) + '</span></td>';
              html += '<td>' + (item.metrics?.f1 != null ? (item.metrics.f1 * 100).toFixed(1) + '%' : '-') + '</td>';
              html += '<td>' + (item.metrics?.recall != null ? (item.metrics.recall * 100).toFixed(1) + '%' : '-') + '</td>';
              html += '<td>' + (item.metrics?.precision != null ? (item.metrics.precision * 100).toFixed(1) + '%' : '-') + '</td>';
              html += '<td>' + (item.latency_s != null ? item.latency_s.toFixed(1) + 's' : '-') + '</td>';
              html += '<td>' + (item.max_iteration || 0) + '</td>';
              html += '<td style="color:' + repResultColor + ';">' + repResultLabel + '</td>';
              html += '</tr>';
            });
          }
        });
        
        if (!hasAnyData) {
          html += '<tr><td colspan="8" style="color:var(--muted)">No data for this query in selected runs.</td></tr>';
        }
        
        html += '</tbody>';
        elQueryRunsTable.innerHTML = html;
        
        // Add click handlers to group header rows (select first rep)
        elQueryRunsTable.querySelectorAll('tr.query-group-header').forEach(row => {
          row.addEventListener('click', (e) => {
            // Don't trigger if clicking the toggle
            if (e.target.closest('.group-toggle') || e.target.closest('td[onclick]')) return;
            
            const groupId = row.dataset.group;
            // Find first rep in this group
            const firstRep = elQueryRunsTable.querySelector('tr.' + groupId + '[data-run]');
            if (firstRep) {
              selectQueryRun(firstRep.dataset.run);
            }
          });
        });
        
        // Add click handlers to individual rep rows
        elQueryRunsTable.querySelectorAll('tr.query-rep-row[data-run]').forEach(row => {
          row.addEventListener('click', () => {
            const runName = row.dataset.run;
            selectQueryRun(runName);
          });
        });
      }

      /**
       * Toggle visibility of rep rows for a group.
       */
      function toggleQueryGroup(groupId, event) {
        if (event) event.stopPropagation();
        
        const repRows = elQueryRunsTable.querySelectorAll('tr.' + groupId);
        const headerRow = elQueryRunsTable.querySelector('tr[data-group="' + groupId + '"]');
        const toggle = headerRow?.querySelector('.group-toggle');
        
        const isExpanded = repRows[0]?.style.display !== 'none';
        
        repRows.forEach(row => {
          row.style.display = isExpanded ? 'none' : '';
        });
        
        if (toggle) {
          toggle.innerHTML = isExpanded ? '&#9654;' : '&#9660;';
        }
      }

      /**
       * Select a run and render its details.
       */
      function selectQueryRun(runName) {
        selectedRunName = runName;
        
        // Update selected row highlight
        if (elQueryRunsTable) {
          // Clear all selections first
          elQueryRunsTable.querySelectorAll('tbody tr').forEach(row => {
            row.classList.remove('selected-run');
          });
          
          // Find and highlight the selected rep row
          const selectedRepRow = elQueryRunsTable.querySelector('tr[data-run="' + runName + '"]');
          if (selectedRepRow) {
            selectedRepRow.classList.add('selected-run');
            
            // Also highlight the parent group header
            const groupClass = Array.from(selectedRepRow.classList).find(c => c.startsWith('query-group-'));
            if (groupClass) {
              const groupHeader = elQueryRunsTable.querySelector('tr[data-group="' + groupClass + '"]');
              if (groupHeader) {
                groupHeader.classList.add('selected-run');
              }
            }
          }
        }
        
        renderQueryDetailContent();
      }

      /**
       * Get tool badge class based on tool name.
       */
      function getToolBadgeClass(toolName) {
        if (toolName.includes('search')) return 'search';
        if (toolName.includes('sparql')) return 'sparql';
        if (toolName.includes('sql')) return 'sql';
        return '';
      }

      /**
       * Get tool display name and icon.
       */
      function getToolInfo(toolName) {
        if (toolName.includes('search')) return { name: 'Search', icon: '&#128269;' };
        if (toolName.includes('sparql')) return { name: 'SPARQL', icon: '&#128302;' };
        if (toolName.includes('sql')) return { name: 'SQL', icon: '&#128451;' };
        return { name: toolName, icon: '&#9881;' };
      }

      /**
       * Render the detailed view for the selected query and run.
       */
      function renderQueryDetailContent() {
        if (!elQueryDetailContent) return;
        
        if (!selectedQueryId || !selectedRunName) {
          elQueryDetailContent.style.display = 'none';
          return;
        }
        
        const item = getItemFromRun(selectedRunName, selectedQueryId);
        if (!item) {
          elQueryDetailContent.innerHTML = '<p class="muted">No data available for this query in the selected run.</p>';
          elQueryDetailContent.style.display = 'block';
          return;
        }
        
        let html = '';
        
        // Query Card
        html += '<div class="query-detail-card">';
        html += '<h4>Query</h4>';
        html += '<div class="query-text">' + escapeHtml(item.input || '') + '</div>';
        html += '</div>';
        
        // Metrics Summary
        html += '<div class="query-detail-card">';
        html += '<h4>Metrics</h4>';
        html += '<div class="exec-grid">';
        
        const metrics = [
          { label: 'F1', value: item.metrics?.f1, pct: true },
          { label: 'Recall', value: item.metrics?.recall, pct: true },
          { label: 'Precision', value: item.metrics?.precision, pct: true },
          { label: 'Latency', value: item.latency_s, suffix: 's' },
          { label: 'Iterations', value: item.max_iteration },
          { label: 'Tool Calls', value: item.tool_calls_total },
        ];
        
        metrics.forEach(m => {
          let display = '-';
          if (m.value != null) {
            if (m.pct) display = (m.value * 100).toFixed(1) + '%';
            else if (m.suffix) display = Number(m.value).toFixed(1) + m.suffix;
            else display = m.value;
          }
          html += '<div class="exec-card"><span class="exec-label">' + m.label + '</span>';
          html += '<span class="exec-value">' + display + '</span></div>';
        });
        
        html += '</div></div>';
        
        // Reasoning Card
        if (item.reasoning) {
          html += '<div class="query-detail-card">';
          html += '<h4>Agent Reasoning</h4>';
          html += '<div class="reasoning-text">' + escapeHtml(item.reasoning) + '</div>';
          html += '</div>';
        }
        
        // Tool Calls Timeline
        const toolCalls = item.tool_calls_detail || [];
        if (toolCalls.length > 0) {
          html += '<div class="query-detail-card">';
          html += '<h4>Tool Calls Timeline (' + toolCalls.length + ' calls)</h4>';
          html += '<div class="tool-timeline">';
          
          // Group by iteration
          const byIteration = {};
          toolCalls.forEach((tc, idx) => {
            const iter = tc.iteration || 1;
            if (!byIteration[iter]) byIteration[iter] = [];
            byIteration[iter].push({ ...tc, originalIndex: idx });
          });
          
          Object.keys(byIteration).sort((a, b) => Number(a) - Number(b)).forEach(iter => {
            byIteration[iter].forEach((tc, idx) => {
              const toolInfo = getToolInfo(tc.name);
              const badgeClass = getToolBadgeClass(tc.name);
              const callId = 'tool-call-' + iter + '-' + idx;
              
              html += '<div class="tool-call-card">';
              html += '<div class="tool-call-header" onclick="toggleToolCallContent(\'' + callId + '\')">';
              html += '<span style="color:var(--muted);font-size:0.8rem;">Iter ' + iter + '</span>';
              html += '<span class="tool-call-badge ' + badgeClass + '">' + toolInfo.icon + ' ' + toolInfo.name + '</span>';
              html += '<span style="margin-left:auto;color:var(--muted);font-size:0.8rem;">&#9660;</span>';
              html += '</div>';
              
              // Tool input if available
              let contentHtml = '';
              if (tc.input) {
                contentHtml += '<div style="color:var(--muted);margin-bottom:8px;font-size:0.75rem;">INPUT:</div>';
                contentHtml += '<div style="margin-bottom:12px;padding:8px;background:var(--bg);border-radius:4px;">';
                contentHtml += escapeHtml(typeof tc.input === 'string' ? tc.input : JSON.stringify(tc.input, null, 2));
                contentHtml += '</div>';
              }
              contentHtml += '<div style="color:var(--muted);margin-bottom:8px;font-size:0.75rem;">OUTPUT:</div>';
              const outputText = tc.content || '(no output)';
              // Truncate very long outputs for display
              const maxLen = 5000;
              const truncatedOutput = outputText.length > maxLen 
                ? outputText.slice(0, maxLen) + '\n\n... (truncated, ' + outputText.length + ' chars total)'
                : outputText;
              contentHtml += escapeHtml(truncatedOutput);
              
              html += '<div class="tool-call-content collapsed" id="' + callId + '">' + contentHtml + '</div>';
              html += '</div>';
            });
          });
          
          html += '</div></div>';
        }
        
        // Results Comparison
        html += '<div class="query-detail-card">';
        html += '<h4>Results</h4>';
        html += '<div class="results-grid">';
        
        const predicted = item.predicted_ids || [];
        const gold = item.gold_ids || [];
        const correct = predicted.filter(id => gold.includes(id));
        const missed = gold.filter(id => !predicted.includes(id));
        const extra = predicted.filter(id => !gold.includes(id));
        
        html += '<div class="result-box"><h5>Predicted (' + predicted.length + ')</h5>';
        html += '<div class="ids">' + (predicted.length > 0 ? predicted.join(', ') : '(none)') + '</div></div>';
        
        html += '<div class="result-box"><h5>Gold (' + gold.length + ')</h5>';
        html += '<div class="ids">' + (gold.length > 0 ? gold.join(', ') : '(none)') + '</div></div>';
        
        html += '<div class="result-box correct"><h5>&#10003; Correct (' + correct.length + ')</h5>';
        html += '<div class="ids">' + (correct.length > 0 ? correct.join(', ') : '(none)') + '</div></div>';
        
        html += '<div class="result-box missed"><h5>&#10007; Missed (' + missed.length + ')</h5>';
        html += '<div class="ids">' + (missed.length > 0 ? missed.join(', ') : '(none)') + '</div></div>';
        
        if (extra.length > 0) {
          html += '<div class="result-box" style="border-color:var(--badge-warn-text);background:var(--badge-warn);">';
          html += '<h5>Extra / False Positives (' + extra.length + ')</h5>';
          html += '<div class="ids">' + extra.join(', ') + '</div></div>';
        }
        
        html += '</div></div>';
        
        // Error info for failed items
        if (item.failed && item.error) {
          html += '<div class="query-detail-card" style="border:1px solid var(--badge-danger-text);background:var(--badge-danger);">';
          html += '<h4 style="color:var(--badge-danger-text);">Error</h4>';
          html += '<div class="reasoning-text" style="color:var(--badge-danger-text);">' + escapeHtml(item.error) + '</div>';
          html += '</div>';
        }
        
        elQueryDetailContent.innerHTML = html;
        elQueryDetailContent.style.display = 'block';
      }

      /**
       * Toggle tool call content visibility.
       */
      function toggleToolCallContent(callId) {
        const content = document.getElementById(callId);
        if (content) {
          content.classList.toggle('collapsed');
        }
      }

      /**
       * Handle query selection from dropdown.
       */
      function onQueryDetailSelect() {
        if (!elQueryDetailSelect) return;
        
        selectedQueryId = elQueryDetailSelect.value || null;
        selectedRunName = null; // Reset run selection
        
        if (selectedQueryId) {
          renderQueryRunsSummary(selectedQueryId);
          
          // Auto-select first run
          const firstRow = elQueryRunsTable?.querySelector('tbody tr[data-run]');
          if (firstRow) {
            selectQueryRun(firstRow.dataset.run);
          }
        } else {
          if (elQueryRunsTable) elQueryRunsTable.innerHTML = '';
          if (elQueryDetailContent) elQueryDetailContent.style.display = 'none';
        }
        
        // Update table row highlighting
        updateScoreTableSelection();
      }

      /**
       * Update the score table to highlight the selected query.
       */
      function updateScoreTableSelection() {
        if (!elScoreTable) return;
        elScoreTable.querySelectorAll('tbody tr').forEach(row => {
          const itemId = row.querySelector('td:first-child')?.textContent;
          row.classList.toggle('selected-row', itemId === selectedQueryId);
        });
      }

      /**
       * Handle click on score table row to select query.
       */
      function onScoreTableRowClick(event) {
        const row = event.target.closest('tr');
        if (!row || row.closest('thead')) return;
        
        const itemId = row.querySelector('td:first-child')?.textContent;
        if (itemId && elQueryDetailSelect) {
          selectedQueryId = itemId;
          elQueryDetailSelect.value = itemId;
          onQueryDetailSelect();
          
          // Scroll to query details section
          const querySection = document.getElementById('query-details-section');
          if (querySection) {
            querySection.scrollIntoView({ behavior: 'smooth' });
          }
        }
      }

      /**
       * Initialize Query Details section.
       */
      function initQueryDetails() {
        buildQueryDetailOptions();
        
        // Event listeners
        if (elQueryDetailSelect) {
          elQueryDetailSelect.addEventListener('change', onQueryDetailSelect);
        }
        if (elScoreTable) {
          elScoreTable.addEventListener('click', onScoreTableRowClick);
        }
      }

      /**
       * Reset Query Details state (for dataset switching).
       */
      function resetQueryDetails() {
        selectedQueryId = null;
        selectedRunName = null;
        buildQueryDetailOptions();
        if (elQueryRunsTable) elQueryRunsTable.innerHTML = '';
        if (elQueryDetailContent) elQueryDetailContent.style.display = 'none';
      }

      let metricChartInst   = null;

      function getSelectedRuns() {
        const sel = new Set(Array.from(elRunsSel.selectedOptions).map(o => o.value));
        // Expand selected group names back to individual runs
        const groups = groupRuns(compareRuns);
        const result = [];
        groups.forEach(g => {
          if (sel.has(g.groupName)) {
            result.push(...g.runs);
          }
        });
        return result;
      }

      function groupRuns(runs) {
        const groupMap = {};
        const groupOrder = [];
        runs.forEach(r => {
          const match = r.run_name.match(/^(.+)-rep-\d+$/);
          const groupName = match ? match[1] : r.run_name;
          if (!groupMap[groupName]) {
            groupMap[groupName] = { groupName, runs: [] };
            groupOrder.push(groupName);
          }
          groupMap[groupName].runs.push(r);
        });
        // Sort group order by agent type then model family
        groupOrder.sort(compareRunNames);
        return groupOrder.map(g => groupMap[g]);
      }

      // Computed metrics that are calculated from item_rows data
      const COMPUTED_METRICS = ['tool_precision', 'tool_recall', 'missed_opportunity_rate', 'latency', 'tool_usage', 'tool_error_rate', 'zero_result_rate', 'iterations'];

      function buildMetricOptions() {
        const names = new Set();
        compareRuns.forEach(r => Object.keys(r.metrics || {}).forEach(n => names.add(n)));
        Object.values(allRunsData).forEach(rd => {
          (rd.item_rows || []).forEach(row => {
            if (row.tool_calls_total !== undefined) names.add('tool_calls_total');
            Object.keys(row.tool_counts || {}).forEach(t => names.add(t + '_count'));
          });
        });
        // Add computed metrics
        COMPUTED_METRICS.forEach(m => names.add(m));
        
        // Prefer f1 as default if available
        const defaultMetric = Array.from(names).find(n => n.toLowerCase() === 'avg_f1' || n.toLowerCase() === 'f1') || Array.from(names)[0] || '';
        elMetricSel.innerHTML = buildGroupedMetricOptionsHTML(names, defaultMetric);
      }

      function getRunMetricValue(run, metric) {
        const isToolMetric = metric === 'tool_calls_total' || metric.endsWith('_count');
        const isComputedMetric = COMPUTED_METRICS.includes(metric);
        const toolName = metric.endsWith('_count') ? metric.slice(0, -6) : null;
        const itemMetric = metric.startsWith('avg_') ? metric.slice(4) : metric;

        // Handle standard metrics from run summary
        if (!isToolMetric && !isComputedMetric) {
          return run.metrics?.[metric] ?? 0;
        }

        const rd = allRunsData[run.run_name];
        if (!rd?.item_rows?.length) return 0;

        // Handle computed metrics (tool_precision, tool_recall, missed_opportunity_rate, latency, tool_error_rate, zero_result_rate)
        if (isComputedMetric) {
          // Handle latency separately
          if (metric === 'latency') {
            let totalLatency = 0;
            let count = 0;
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              const latency = row.latency_s;
              if (latency !== null && latency !== undefined && !Number.isNaN(latency)) {
                totalLatency += latency;
                count++;
              }
            });
            return count > 0 ? totalLatency / count : 0;
          }
          
          // Handle tool_error_rate - aggregate across all items for the run
          if (metric === 'tool_error_rate') {
            let totalCalls = 0;
            let totalErrors = 0;
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              const tes = row.tool_error_stats || {};
              totalCalls += tes.total_calls || 0;
              totalErrors += tes.error_count || 0;
            });
            return totalCalls > 0 ? totalErrors / totalCalls : 0;
          }
          
          // Handle zero_result_rate - aggregate across all items for the run
          if (metric === 'zero_result_rate') {
            let totalQueries = 0;
            let zeroResults = 0;
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              const zrs = row.zero_result_stats || {};
              totalQueries += zrs.total_queries || 0;
              zeroResults += zrs.zero_result_queries || 0;
            });
            return totalQueries > 0 ? zeroResults / totalQueries : 0;
          }
          
          // Handle gt_discovery based metrics
          let totalToolIds = 0;
          let totalGoldIds = 0;
          let totalGoldFound = 0;
          let totalFoundNotReturned = 0;
          
          rd.item_rows.forEach(row => {
            if (row.failed) return;
            const gtd = row.gt_discovery || {};
            const goldCount = row.gold_count || 0;
            
            totalToolIds += gtd.total_ids_from_tools || 0;
            totalGoldIds += goldCount;
            totalGoldFound += (gtd.found_ids || []).length;
            totalFoundNotReturned += (gtd.found_but_not_returned || []).length;
          });
          
          if (metric === 'tool_precision') {
            return totalToolIds > 0 ? totalGoldFound / totalToolIds : 0;
          } else if (metric === 'tool_recall') {
            return totalGoldIds > 0 ? totalGoldFound / totalGoldIds : 0;
          } else if (metric === 'missed_opportunity_rate') {
            return totalGoldFound > 0 ? totalFoundNotReturned / totalGoldFound : 0;
          }
          
          // Handle iterations metric
          if (metric === 'iterations') {
            let totalIterations = 0;
            let count = 0;
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              const recallProg = row.gt_discovery?.recall_by_call_index || [];
              if (recallProg.length > 0) {
                totalIterations += recallProg[recallProg.length - 1][0];
                count++;
              }
            });
            return count > 0 ? totalIterations / count : 0;
          }
        }

        // Handle tool count metrics
        let total = 0;
        let count = 0;
        rd.item_rows.forEach(row => {
          if (row.failed) return;
          let val = 0;
          if (metric === 'tool_calls_total') {
            val = row.tool_calls_total ?? 0;
          } else if (toolName) {
            val = row.tool_counts?.[toolName] ?? 0;
          }
          total += val;
          count++;
        });
        return count > 0 ? total / count : 0;
      }

      /**
       * Adjust color lightness. Amount > 0 lightens, < 0 darkens.
       */
      function adjustColorLightness(hex, amount) {
        // Convert hex to RGB
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);
        
        // Adjust lightness
        if (amount > 0) {
          // Lighten: blend with white
          r = Math.round(r + (255 - r) * amount);
          g = Math.round(g + (255 - g) * amount);
          b = Math.round(b + (255 - b) * amount);
        } else {
          // Darken: blend with black
          r = Math.round(r * (1 + amount));
          g = Math.round(g * (1 + amount));
          b = Math.round(b * (1 + amount));
        }
        
        // Clamp values
        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        b = Math.max(0, Math.min(255, b));
        
        return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
      }

      /**
       * Generate colors for each group based on agent type and model.
       * GPT-5 gets darker shade, GPT-5-mini gets lighter shade.
       */
      function getGroupColors(groups) {
        return groups.map(g => {
          const agentType = parseAgentType(g.groupName);
          const modelFamily = parseModelFamily(g.groupName);
          const baseColor = getAgentColor(agentType);
          
          // Adjust lightness based on model
          if (modelFamily === 'gpt-5-mini') {
            return adjustColorLightness(baseColor, 0.3); // Lighter
          } else {
            return adjustColorLightness(baseColor, -0.15); // Slightly darker
          }
        });
      }

      /**
       * Generate style properties (opacity, borderDash) for each group based on model.
       * GPT-5 gets solid style, GPT-5-mini gets lighter/dashed style.
       */
      function getGroupStyles(groups) {
        return groups.map(g => {
          const modelFamily = parseModelFamily(g.groupName);
          if (modelFamily === 'gpt-5-mini') {
            return { opacity: '77', borderDash: [4, 4] }; // Lighter, dashed
          } else {
            return { opacity: 'CC', borderDash: [] }; // Solid, darker
          }
        });
      }

      /**
       * Generate short labels for chart axes (Agent + Model).
       */
      function getGroupLabels(groups) {
        return groups.map(g => {
          const agentType = parseAgentType(g.groupName);
          const modelName = extractModelName(g.groupName);
          const agentLabel = AGENT_COLORS[agentType]?.name || 'Auto';
          return agentLabel + ' + ' + modelName;
        });
      }

      /**
       * Generate chip label data for the chipLabels plugin.
       */
      function getGroupChipLabels(groups) {
        const dark = isDarkMode();
        return groups.map(g => {
          const agentType = parseAgentType(g.groupName);
          const modelName = extractModelName(g.groupName);
          const modelFamily = parseModelFamily(modelName);
          
          const agent = AGENT_COLORS[agentType] || AGENT_COLORS['sql-sparql'];
          const model = MODEL_COLORS[modelFamily] || MODEL_COLORS['gpt-5'];
          
          // Get theme-appropriate colors
          const agentColor = dark ? agent.dark : agent.light;
          const modelColor = dark ? model.dark : model.light;
          
          // Background colors (lighter versions)
          const agentBg = dark ? agentColor + '33' : agentColor + '22';
          const modelBg = dark ? modelColor + '33' : modelColor + '22';
          
          return {
            agent: agent.name,
            model: model.name,
            agentColor: agentColor,
            modelColor: modelColor,
            agentBg: agentBg,
            modelBg: modelBg,
          };
        });
      }

      // Metrics that support stacked/grouped toggle (tool breakdown metrics excluding tool_usage which is always stacked)
      const TOOL_STACKABLE_METRICS = ['tool_precision', 'tool_recall', 'tool_error_rate', 'zero_result_rate'];
      
      /**
       * Get a description of how to interpret the selected metric.
       * @param {string} metric - The metric name
       * @param {boolean} isStacked - Whether the chart is stacked (for tool metrics)
       * @returns {string} Human-readable description
       */
      function getMetricDescription(metric, isStacked = false) {
        const descriptions = {
          // Core performance metrics
          'f1': 'F1 score balances precision and recall. Higher is better. A score of 1.0 means perfect retrieval.',
          'avg_f1': 'F1 score balances precision and recall. Higher is better. A score of 1.0 means perfect retrieval.',
          'recall': 'Recall measures what fraction of the correct answers were found. Higher is better.',
          'avg_recall': 'Recall measures what fraction of the correct answers were found. Higher is better.',
          'precision': 'Precision measures what fraction of returned answers were correct. Higher is better.',
          'avg_precision': 'Precision measures what fraction of returned answers were correct. Higher is better.',
          
          // Hit/MRR metrics
          'hit@1': 'Hit@1 measures if the top result is correct. Higher is better.',
          'hit@5': 'Hit@5 measures if a correct answer appears in the top 5 results. Higher is better.',
          'hit@10': 'Hit@10 measures if a correct answer appears in the top 10 results. Higher is better.',
          'hit@20': 'Hit@20 measures if a correct answer appears in the top 20 results. Higher is better.',
          'mrr': 'Mean Reciprocal Rank measures how high the first correct answer ranks. Higher is better.',
          'avg_mrr': 'Mean Reciprocal Rank measures how high the first correct answer ranks. Higher is better.',
          
          // Tool metrics with stacked/grouped variants
          'tool_usage': 'Average number of tool calls per query, broken down by tool type. The total height shows overall tool usage.',
          'tool_precision': isStacked
            ? 'Per-tool precision stacked to show cumulative signal quality. Each segment shows what fraction of that tool\'s results were gold answers. Higher total = tools returning more relevant results overall.'
            : 'Per-tool precision compared side-by-side. Shows what fraction of each tool\'s returned IDs were gold answers. Higher = that tool returns more relevant results with less noise.',
          'tool_recall': isStacked
            ? 'Per-tool recall contributions stacked to show total coverage. Each segment shows what fraction of gold answers that tool found first. The total height equals overall tool recall.'
            : 'Per-tool recall compared side-by-side. Shows what fraction of gold answers each tool discovered. Note: in grouped view, values may overlap since the same gold ID can be found by multiple tools.',
          'tool_error_rate': isStacked
            ? 'Each tool\'s contribution to the overall error rate. Stacked total = actual error rate (total errors ÷ total calls). Hover for per-tool rate.'
            : 'Per-tool error rates (errors ÷ calls for that tool). Lower is better. Note: differs from "% of items affected" which counts items with ≥1 error.',
          'zero_result_rate': isStacked
            ? 'Each tool\'s contribution to the overall zero-result rate. Stacked total = actual zero-result rate (empty results ÷ total queries). Hover for per-tool rate.'
            : 'Per-tool zero-result rates (empty results ÷ queries for that tool). Lower is better.',
          
          // Other computed metrics
          'missed_opportunity_rate': 'Fraction of gold answers that tools found but the agent failed to include in the final response. Lower is better - indicates the agent is utilizing tool results effectively.',
          'latency': 'Average time to complete a query in seconds. Lower is better.',
          'iterations': 'Average number of agent iterations (reasoning cycles) per query. Fewer iterations may indicate more efficient problem-solving.',
        };
        
        // Handle avg_ prefixed versions
        const baseMetric = metric.replace(/^avg_/, '');
        return descriptions[metric] || descriptions[baseMetric] || 
          'Average score across all queries. Error bars show min/max across repetitions when available.';
      }
      
      function renderMetricChart(runs, metric) {
        if (metricChartInst) metricChartInst.destroy();
        
        // Update the chart title to show the actual metric name
        const metricTitle = document.getElementById('compare-metric-title');
        if (metricTitle) {
          const displayName = METRIC_DISPLAY_NAMES[metric] || metric.replace(/^avg_/, '').replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
          metricTitle.textContent = displayName + ' by Run';
        }
        
        // Show/hide stacked toggle for applicable metrics
        const stackToggle = document.getElementById('compare-stack-toggle');
        if (stackToggle) {
          stackToggle.style.display = TOOL_STACKABLE_METRICS.includes(metric) ? 'block' : 'none';
        }
        
        // Special handling for tool metrics - render stacked bars by tool
        if (TOOL_STACKED_METRICS.includes(metric)) {
          const useStacked = metric === 'tool_usage' || 
            (TOOL_STACKABLE_METRICS.includes(metric) && document.getElementById('compare-stacked-checkbox')?.checked);
          
          // Update description for tool metrics
          const descEl = document.getElementById('compare-metric-description');
          if (descEl) {
            descEl.textContent = getMetricDescription(metric, useStacked);
          }
          
          renderRunComparisonToolStackedChart(runs, metric, useStacked);
          return;
        }
        
        // Update description for non-tool metrics
        const descEl = document.getElementById('compare-metric-description');
        if (descEl) {
          descEl.textContent = getMetricDescription(metric, false);
        }
        
        const groups = groupRuns(runs);
        const labels = getGroupLabels(groups);
        const chipLabels = getGroupChipLabels(groups);
        const summaries = groups.map(g =>
          summarize(g.runs.map(r => getRunMetricValue(r, metric)))
        );
        const colors = getGroupColors(groups);
        const styles = getGroupStyles(groups);
        const bgColors = colors.map((c, i) => c + styles[i].opacity);
        const usePercentage = isPercentageMetric(metric);

        metricChartInst = new Chart(document.getElementById('compare-metric-chart'), {
          type: 'bar',
          data: {
            labels: labels.map(() => ''),  // Empty labels - chips drawn by plugin
            datasets: [{
              data: summaries.map(s => s.mean),
              backgroundColor: bgColors,
              borderColor: colors,
              borderWidth: styles.map(s => s.borderDash.length > 0 ? 3 : 2),
              errorBars: summaries.map(s =>
                s.n > 1 ? { min: s.min, max: s.max } : null
              ),
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: { bottom: 55 }  // Extra space for chip labels
            },
            scales: {
              x: { 
                ticks: { display: false },  // Hide default labels
                grid: { display: false }
              },
              y: {
                beginAtZero: true,
                ticks: usePercentage ? {
                  callback: function(value) { return (value * 100).toFixed(0) + '%'; }
                } : {},
              },
            },
            plugins: {
              legend: { display: false },
              chipLabels: { labels: chipLabels },
              tooltip: {
                callbacks: {
                  label: function(ctx) {
                    const s = summaries[ctx.dataIndex];
                    if (!s || s.mean === null) return '';
                    if (usePercentage) {
                      if (s.n <= 1) return 'Value: ' + (s.mean * 100).toFixed(1) + '%';
                      return [
                        'Mean: ' + (s.mean * 100).toFixed(1) + '%',
                        'SD: ' + (s.sd * 100).toFixed(1) + '%',
                        'Min: ' + (s.min * 100).toFixed(1) + '%',
                        'Max: ' + (s.max * 100).toFixed(1) + '%',
                        'Reps: ' + s.n,
                      ];
                    }
                    if (s.n <= 1) return 'Value: ' + fmt(s.mean);
                    return [
                      'Mean: ' + fmt(s.mean),
                      'SD: ' + fmt(s.sd),
                      'Min: ' + fmt(s.min),
                      'Max: ' + fmt(s.max),
                      'Reps: ' + s.n,
                    ];
                  }
                }
              }
            },
          },
        });
      }
      
      /**
       * Render bar chart for tool metrics in Run Comparison.
       * Shows Search, SQL, SPARQL metrics per run group.
       * @param {Array} runs - Selected runs
       * @param {string} metric - The metric to display
       * @param {boolean} useStacked - Whether to stack bars (true) or group them (false)
       */
      function renderRunComparisonToolStackedChart(runs, metric, useStacked) {
        const groups = groupRuns(runs);
        const labels = getGroupLabels(groups);
        const chipLabels = getGroupChipLabels(groups);
        const toolNames = ['search_entities_tool', 'execute_sql_query_tool', 'execute_sparql_query_tool'];
        const toolDisplayNames = toolNames.map(getToolDisplayName);
        
        const isPercentage = metric !== 'tool_usage';
        const isRateMetric = metric === 'tool_error_rate' || metric === 'zero_result_rate';
        const yAxisLabel = metric === 'tool_usage' ? 'Avg Calls / Item' :
                          metric === 'tool_error_rate' ? 'Error Rate' :
                          metric === 'zero_result_rate' ? 'Zero Result Rate' :
                          metric === 'tool_precision' ? 'Precision' :
                          metric === 'tool_recall' ? 'Recall' : metric;
        
        // For stacked rate metrics, we need to collect totals first to use common denominator
        // This makes the stacked total equal the actual overall rate
        const groupTotals = groups.map(g => {
          let totalCalls = 0;  // common denominator for rate metrics
          let totalItems = 0;  // for tool_usage
          
          g.runs.forEach(run => {
            const rd = allRunsData[run.run_name];
            if (!rd?.item_rows) return;
            
            rd.item_rows.forEach(row => {
              if (row.failed) return;
              totalItems++;
              
              if (metric === 'tool_error_rate') {
                totalCalls += row.tool_error_stats?.total_calls || 0;
              } else if (metric === 'zero_result_rate') {
                totalCalls += row.zero_result_stats?.total_queries || 0;
              }
            });
          });
          
          return { totalCalls, totalItems };
        });
        
        const datasets = toolNames.map((toolName, idx) => {
          const data = groups.map((g, groupIdx) => {
            // Aggregate across all runs in this group
            let totalA = 0;  // numerator (errors, zeros, calls, or contribution values)
            let totalB = 0;  // denominator (tool-specific calls, queries, or item count)
            
            g.runs.forEach(run => {
              const rd = allRunsData[run.run_name];
              if (!rd?.item_rows) return;
              
              rd.item_rows.forEach(row => {
                if (row.failed) return;
                
                if (metric === 'tool_usage') {
                  totalA += row.tool_counts?.[toolName] || 0;
                  totalB++;  // count items
                } else if (metric === 'tool_error_rate') {
                  const stats = row.tool_error_stats?.by_tool?.[toolName];
                  if (stats) {
                    totalA += stats.errors || 0;
                    totalB += stats.total || 0;
                  }
                } else if (metric === 'zero_result_rate') {
                  const stats = row.zero_result_stats?.by_tool?.[toolName];
                  if (stats) {
                    totalA += stats.zero || 0;
                    totalB += stats.total || 0;
                  }
                } else if (metric === 'tool_precision' || metric === 'tool_recall') {
                  // Get from the last entry in the progression arrays
                  const gtd = row.gt_discovery || {};
                  const progression = metric === 'tool_precision' 
                    ? gtd.precision_by_call_index 
                    : gtd.recall_by_call_index;
                  if (progression && progression.length > 0) {
                    const lastEntry = progression[progression.length - 1];
                    const toolContributions = lastEntry[2] || {};
                    const toolValue = toolContributions[toolName] || 0;
                    totalA += toolValue;
                    totalB++;
                  }
                }
              });
            });
            
            if (metric === 'tool_usage') {
              return totalB > 0 ? totalA / totalB : 0;
            } else if (metric === 'tool_precision' || metric === 'tool_recall') {
              return totalB > 0 ? totalA / totalB : 0;  // average of per-item values
            }
            
            // For rate metrics (tool_error_rate, zero_result_rate)
            if (isRateMetric && useStacked) {
              // Stacked: show contribution to overall rate (numerator / total calls across ALL tools)
              // This way stacked total = actual overall error/zero rate
              const commonDenom = groupTotals[groupIdx].totalCalls;
              return commonDenom > 0 ? totalA / commonDenom : 0;
            } else {
              // Grouped: show per-tool rate (numerator / that tool's calls only)
              return totalB > 0 ? totalA / totalB : 0;
            }
          });
          
          const color = getToolColor(toolName);
          return {
            label: toolDisplayNames[idx],
            data: data,
            backgroundColor: color + 'CC',
            borderColor: color,
            borderWidth: 1,
            // Store per-tool rates for tooltip in stacked mode
            _perToolRates: isRateMetric && useStacked ? groups.map((g, groupIdx) => {
              let toolErrors = 0;
              let toolCalls = 0;
              g.runs.forEach(run => {
                const rd = allRunsData[run.run_name];
                if (!rd?.item_rows) return;
                rd.item_rows.forEach(row => {
                  if (row.failed) return;
                  const stats = metric === 'tool_error_rate' 
                    ? row.tool_error_stats?.by_tool?.[toolName]
                    : row.zero_result_stats?.by_tool?.[toolName];
                  if (stats) {
                    toolErrors += metric === 'tool_error_rate' ? (stats.errors || 0) : (stats.zero || 0);
                    toolCalls += stats.total || 0;
                  }
                });
              });
              return toolCalls > 0 ? toolErrors / toolCalls : 0;
            }) : null
          };
        });
        
        // Calculate dynamic y-axis max
        let yMax;
        if (isPercentage) {
          if (useStacked) {
            // For stacked charts, calculate max of sums across all groups
            const stackedMaxes = labels.map((_, groupIdx) => {
              return datasets.reduce((sum, ds) => sum + (ds.data[groupIdx] || 0), 0);
            });
            const maxVal = stackedMaxes.length > 0 ? Math.max(...stackedMaxes) : 0;
            yMax = Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1);
          } else {
            // For grouped charts, calculate max of all individual values
            const allValues = datasets.flatMap(ds => ds.data).filter(v => v != null);
            const maxVal = allValues.length > 0 ? Math.max(...allValues) : 0;
            yMax = Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1);
          }
        }
        
        metricChartInst = new Chart(document.getElementById('compare-metric-chart'), {
          type: 'bar',
          data: {
            labels: labels.map(() => ''),  // Empty labels - chips drawn by plugin
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: { bottom: 55 }  // Extra space for chip labels
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { font: { size: 10 }, boxWidth: 12 }
              },
              chipLabels: { labels: chipLabels },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    if (!isPercentage) {
                      return `${ctx.dataset.label}: ${ctx.raw.toFixed(2)} calls/item`;
                    }
                    // For stacked rate metrics, show both contribution and per-tool rate
                    if (isRateMetric && useStacked && ctx.dataset._perToolRates) {
                      const contribution = (ctx.raw * 100).toFixed(1);
                      const perToolRate = (ctx.dataset._perToolRates[ctx.dataIndex] * 100).toFixed(1);
                      return `${ctx.dataset.label}: ${contribution}% of total (${perToolRate}% of ${ctx.dataset.label} calls)`;
                    }
                    return `${ctx.dataset.label}: ${(ctx.raw * 100).toFixed(1)}%`;
                  }
                }
              }
            },
            scales: {
              x: { 
                stacked: useStacked, 
                ticks: { display: false },  // Hide default labels
                grid: { display: false }
              },
              y: {
                stacked: useStacked,
                beginAtZero: true,
                max: yMax,
                ticks: isPercentage ? { callback: (v) => (v * 100).toFixed(0) + '%' } : {},
                title: { display: true, text: yAxisLabel, font: { size: 11 } }
              }
            }
          }
        });
      }

      /**
       * Extract a computed metric value from a single item row.
       * Returns null if the metric cannot be computed for this row.
       */
      function getItemComputedMetricValue(row, metric) {
        if (row.failed) return null;
        
        const gtd = row.gt_discovery || {};
        const goldCount = row.gold_count || 0;
        
        switch (metric) {
          case 'latency':
            return row.latency_s ?? null;
            
          case 'tool_usage':
            return row.tool_calls_total ?? null;
            
          case 'iterations': {
            const recallProg = gtd.recall_by_call_index || [];
            if (recallProg.length > 0) {
              return recallProg[recallProg.length - 1][0]; // Last iteration index
            }
            return row.max_iteration || null;
          }
          
          case 'tool_precision': {
            const totalToolIds = gtd.total_ids_from_tools || 0;
            const goldFound = (gtd.found_ids || []).length;
            return totalToolIds > 0 ? goldFound / totalToolIds : null;
          }
          
          case 'tool_recall': {
            const goldFound = (gtd.found_ids || []).length;
            return goldCount > 0 ? goldFound / goldCount : null;
          }
          
          case 'missed_opportunity_rate': {
            const goldFound = (gtd.found_ids || []).length;
            const foundNotReturned = (gtd.found_but_not_returned || []).length;
            return goldFound > 0 ? foundNotReturned / goldFound : null;
          }
          
          case 'tool_error_rate': {
            const tes = row.tool_error_stats || {};
            const totalCalls = tes.total_calls || 0;
            const errorCount = tes.error_count || 0;
            return totalCalls > 0 ? errorCount / totalCalls : null;
          }
          
          case 'zero_result_rate': {
            const zrs = row.zero_result_stats || {};
            const totalQueries = zrs.total_queries || 0;
            const zeroResults = zrs.zero_result_queries || 0;
            return totalQueries > 0 ? zeroResults / totalQueries : null;
          }
          
          default:
            return null;
        }
      }
      
      function collectItemScores(runs, metric) {
        const isToolMetric = metric === 'tool_calls_total' || metric.endsWith('_count');
        const isComputedMetric = COMPUTED_METRICS.includes(metric);
        const toolName     = metric.endsWith('_count') ? metric.slice(0, -6) : null;
        const itemMetric   = metric.startsWith('avg_') ? metric.slice(4) : metric;
        const groups       = groupRuns(runs);

        const byItem = {};

        groups.forEach(group => {
          group.runs.forEach(run => {
            const rd = allRunsData[run.run_name];
            if (!rd?.item_rows) return;
            rd.item_rows.forEach(row => {
              const key = row.item_id ?? row.input ?? '';
              if (!byItem[key]) {
                byItem[key] = { item_id: row.item_id, input: row.input ?? '', groups: {} };
              }
              if (!byItem[key].groups[group.groupName]) {
                byItem[key].groups[group.groupName] = { values: [], failCount: 0, errors: [] };
              }
              const g = byItem[key].groups[group.groupName];
              if (row.failed) {
                g.failCount++;
                g.errors.push(row.error || 'Unknown error');
                return;
              }
              let val = null;
              if (isComputedMetric) {
                // Handle computed metrics (tool_precision, tool_recall, etc.)
                val = getItemComputedMetricValue(row, metric);
              } else if (isToolMetric) {
                val = metric === 'tool_calls_total'
                  ? (row.tool_calls_total ?? 0)
                  : (row.tool_counts?.[toolName] ?? 0);
              } else {
                val = row.metrics?.[itemMetric] ?? null;
              }
              if (val !== null && !Number.isNaN(val)) {
                g.values.push(val);
              }
            });
          });
        });
        return { byItem, groups };
      }

      /**
       * Format a value for display, handling percentages and precision.
       * @param {number} value - The value to format
       * @param {number} precision - Decimal places
       * @param {boolean} isPercentage - Whether to display as percentage
       * @param {string} suffix - Optional suffix (e.g., 's' for seconds)
       * @returns {string} Formatted value
       */
      function fmtValue(value, precision, isPercentage, suffix = '') {
        if (value === null || value === undefined || Number.isNaN(value)) return '-';
        if (isPercentage) {
          return (value * 100).toFixed(precision) + '%';
        }
        return Number(value).toFixed(precision) + suffix;
      }

      function renderScoreTable(runs, metric, collected) {
        const { byItem, groups } = collected;
        const isToolMetric = metric === 'tool_calls_total' || metric.endsWith('_count');
        const isComputedMetric = COMPUTED_METRICS.includes(metric);
        const isPercentage = PERCENTAGE_METRICS.includes(metric) || PERCENTAGE_METRICS.includes(metric.replace(/^avg_/, ''));
        
        // Determine precision and suffix based on metric type
        let precision = 1; // Default for percentages
        let suffix = '';
        if (isToolMetric || metric === 'tool_usage' || metric === 'iterations') {
          precision = 1; // Tool counts and iterations - show 1 decimal
        } else if (metric === 'latency') {
          precision = 1; // Latency in seconds - show 1 decimal
          suffix = 's';
        } else if (!isPercentage) {
          precision = 3; // Other non-percentage metrics
        }
        
        const groupHeaders = groups.map(g => {
          const agentType = parseAgentType(g.groupName);
          const modelName = extractModelName(g.groupName);
          const modelFamily = parseModelFamily(modelName);
          const repsLabel = g.runs.length > 1 ? ' <span style="color:var(--muted);font-weight:400">(n=' + g.runs.length + ')</span>' : '';
          return '<th style="vertical-align:bottom;padding-bottom:8px;">' +
            '<div style="display:flex;flex-direction:column;gap:4px;align-items:center;">' +
            createAgentChip(agentType, true) +
            createModelChip(modelFamily, modelName, true) +
            repsLabel +
            '</div></th>';
        }).join('');
        const entries = Object.values(byItem).slice(0, 100);

        const rows = entries.map(e => {
          const cells = groups.map(g => {
            const gd = e.groups[g.groupName];
            if (!gd || (gd.values.length === 0 && gd.failCount === 0)) {
              return '<td data-score="">-</td>';
            }
            if (gd.values.length === 0 && gd.failCount > 0) {
              const errMsg = gd.errors.join('; ');
              return '<td data-score="" data-failed="true" title="' + escapeHtml(errMsg) + '" style="background:#f0f0f0;color:#aaa;text-align:center;cursor:help">&#10007;</td>';
            }
            const s = summarize(gd.values);
            const showSd = s.n > 1 && s.sd > 0;
            const display = showSd
              ? fmtValue(s.mean, precision, isPercentage, suffix) + ' <span style="color:var(--muted);font-size:0.8em">±' + fmtValue(s.sd, precision, isPercentage, '') + '</span>'
              : fmtValue(s.mean, precision, isPercentage, suffix);
            const tooltip = s.n > 1
              ? 'Mean: ' + fmtValue(s.mean, precision, isPercentage, suffix) + ', SD: ' + fmtValue(s.sd, precision, isPercentage, '') + ', Min: ' + fmtValue(s.min, precision, isPercentage, suffix) + ', Max: ' + fmtValue(s.max, precision, isPercentage, suffix) + ', Reps: ' + s.n
              : '';
            return '<td data-score="' + (s.mean ?? '') + '" title="' + tooltip + '">' + display + '</td>';
          }).join('');
          const hasFailure = groups.some(g => (e.groups[g.groupName]?.failCount ?? 0) > 0);
          return '<tr' + (hasFailure ? ' class="row-fail"' : '') + '><td>' + (e.item_id ?? '') + '</td><td class="query-cell" title="' + escapeHtml(e.input) + '">' + escapeHtml(e.input) + '</td>' + cells + '</tr>';
        });

        elScoreTable.innerHTML =
          '<thead><tr><th>Item ID</th><th>Query</th>' + groupHeaders + '</tr></thead><tbody>' +
          rows.join('') + '</tbody>';

        applyHeatmap(elScoreTable, metric);
      }

      // Metrics where lower values are better (should be colored red=high, green=low)
      const LOWER_IS_BETTER_METRICS = [
        'latency',
        'tool_error_rate',
        'zero_result_rate', 
        'missed_opportunity_rate',
        'iterations',  // Fewer iterations is generally better (more efficient)
      ];
      
      // Absolute thresholds for specific metrics (overrides relative coloring)
      // Format: { metric: { green: threshold, red: threshold } }
      // Values <= green threshold are fully green, values >= red threshold are fully red
      const METRIC_ABSOLUTE_THRESHOLDS = {
        'latency': { green: 30, red: 80 },  // 0-30s green, 80s+ red
      };

      function applyHeatmap(table, metric) {
        const cells = Array.from(table.querySelectorAll('td[data-score]:not([data-failed])'));
        const vals = cells.map(c => parseFloat(c.dataset.score)).filter(v => !Number.isNaN(v));
        if (vals.length === 0) return;
        const lo = Math.min(...vals);
        const hi = Math.max(...vals);
        const dark = isDarkMode();
        
        // Check if this metric should have inverted coloring (lower = better = green)
        const invertColors = LOWER_IS_BETTER_METRICS.includes(metric);
        
        // Check for absolute thresholds
        const absThresholds = METRIC_ABSOLUTE_THRESHOLDS[metric];
        
        cells.forEach(cell => {
          const v = parseFloat(cell.dataset.score);
          if (Number.isNaN(v)) return;
          
          let t;
          if (absThresholds) {
            // Use absolute thresholds: green threshold -> red threshold
            const { green: greenThresh, red: redThresh } = absThresholds;
            if (v <= greenThresh) {
              t = 1; // Fully green
            } else if (v >= redThresh) {
              t = 0; // Fully red
            } else {
              // Linear interpolation between thresholds
              t = 1 - (v - greenThresh) / (redThresh - greenThresh);
            }
          } else {
            // Use relative coloring based on data range
            // t goes from 0 (lowest value) to 1 (highest value)
            t = hi === lo ? 0.5 : (v - lo) / (hi - lo);
            // For "lower is better" metrics, invert so low values get green (high t)
            if (invertColors) {
              t = 1 - t;
            }
          }
          
          if (dark) {
            cell.style.backgroundColor = 'hsl(' + (120 * t).toFixed(0) + ', 35%, 28%)';
          } else {
            cell.style.backgroundColor = 'hsl(' + (120 * t).toFixed(0) + ', 55%, 85%)';
          }
        });
        if (dark) {
          Array.from(table.querySelectorAll('td[data-failed="true"]')).forEach(cell => {
            cell.style.background = '#3a3a40';
            cell.style.color = '#777';
          });
        } else {
          Array.from(table.querySelectorAll('td[data-failed="true"]')).forEach(cell => {
            cell.style.background = '#f0f0f0';
            cell.style.color = '#aaa';
          });
        }
      }

      /* ── Correlation matrix helper functions ── */
      function getRunScoreVector(runName, metric) {
        const rd = allRunsData[runName];
        if (!rd?.item_rows) return {};

        const isToolMetric = metric === 'tool_calls_total' || metric.endsWith('_count');
        const toolName     = metric.endsWith('_count') ? metric.slice(0, -6) : null;
        const itemMetric   = metric.startsWith('avg_') ? metric.slice(4) : metric;

        const scores = {};
        rd.item_rows.forEach(row => {
          const key = row.item_id ?? row.input ?? '';
          if (row.failed) return;
          let val = null;
          if (isToolMetric) {
            val = metric === 'tool_calls_total'
              ? (row.tool_calls_total ?? 0)
              : (row.tool_counts?.[toolName] ?? 0);
          } else {
            val = row.metrics?.[itemMetric] ?? null;
          }
          if (val !== null && !Number.isNaN(val)) {
            scores[key] = val;
          }
        });
        return scores;
      }

      function getPairedValues(vecA, vecB, excludeZeros) {
        const keys = new Set([...Object.keys(vecA), ...Object.keys(vecB)]);
        const pairsA = [];
        const pairsB = [];
        keys.forEach(k => {
          const a = vecA[k];
          const b = vecB[k];
          if (a === undefined || b === undefined) return;
          if (excludeZeros && a === 0 && b === 0) return;
          pairsA.push(a);
          pairsB.push(b);
        });
        return { a: pairsA, b: pairsB };
      }

      function pearson(xs, ys) {
        const n = xs.length;
        if (n < 2) return null;
        const mx = xs.reduce((s, v) => s + v, 0) / n;
        const my = ys.reduce((s, v) => s + v, 0) / n;
        let num = 0, dx2 = 0, dy2 = 0;
        for (let i = 0; i < n; i++) {
          const dx = xs[i] - mx;
          const dy = ys[i] - my;
          num += dx * dy;
          dx2 += dx * dx;
          dy2 += dy * dy;
        }
        const denom = Math.sqrt(dx2) * Math.sqrt(dy2);
        return denom === 0 ? null : num / denom;
      }

      function corrColor(r) {
        if (r === null) return 'var(--panel)';
        const dark = isDarkMode();
        const t = (r + 1) / 2;
        if (dark) {
          if (t < 0.5) {
            const s = t * 2;
            const r_ = 140 - Math.round(40 * s);
            const g = 60 + Math.round(30 * s);
            const b = 60 + Math.round(30 * s);
            return 'rgb(' + r_ + ',' + g + ',' + b + ')';
          } else {
            const s = (t - 0.5) * 2;
            const r_ = 100 - Math.round(50 * s);
            const g = 90 + Math.round(50 * s);
            const b = 90 - Math.round(30 * s);
            return 'rgb(' + r_ + ',' + g + ',' + b + ')';
          }
        }
        if (t < 0.5) {
          const s = t * 2;
          const r_ = 220 + Math.round(35 * s);
          const g = 180 + Math.round(75 * s);
          const b = 180 + Math.round(75 * s);
          return 'rgb(' + r_ + ',' + g + ',' + b + ')';
        } else {
          const s = (t - 0.5) * 2;
          const r_ = 255 - Math.round(60 * s);
          const g = 255 - Math.round(20 * s);
          const b = 255 - Math.round(70 * s);
          return 'rgb(' + r_ + ',' + g + ',' + b + ')';
        }
      }

      function getGroupScoreVector(group, metric) {
        const runVectors = group.runs.map(r => getRunScoreVector(r.run_name, metric));
        const allKeys = new Set();
        runVectors.forEach(v => Object.keys(v).forEach(k => allKeys.add(k)));
        const meanVec = {};
        allKeys.forEach(k => {
          const vals = runVectors.map(v => v[k]).filter(v => v !== undefined);
          if (vals.length > 0) {
            meanVec[k] = vals.reduce((s, v) => s + v, 0) / vals.length;
          }
        });
        return meanVec;
      }

      function renderCompareCorrMatrix(runs, metric) {
        const elCompareCorrTable = document.getElementById('compare-corr-matrix-table');
        const elCompareCorrNote = document.getElementById('compare-corr-note');
        
        const groups = groupRuns(runs);
        const groupNames = groups.map(g => g.groupName);

        if (groupNames.length < 2) {
          elCompareCorrTable.innerHTML = '<tbody><tr><td style="color:var(--muted)">Select at least 2 configurations to see correlation.</td></tr></tbody>';
          elCompareCorrNote.textContent = '';
          return;
        }

        // Get score vectors for each group
        const vectors = {};
        groups.forEach(g => { vectors[g.groupName] = getGroupScoreVector(g, metric); });

        // Build lower triangle matrix (symmetric)
        const matrix = [];
        let minPairs = Infinity;
        for (let i = 0; i < groupNames.length; i++) {
          const row = [];
          for (let j = 0; j <= i; j++) {
            if (i === j) {
              row.push({ r: 1.0, n: 0, diag: true });
            } else {
              const { a, b } = getPairedValues(vectors[groupNames[i]], vectors[groupNames[j]], false);
              row.push({ r: pearson(a, b), n: a.length, diag: false });
              if (a.length < minPairs) minPairs = a.length;
            }
          }
          matrix.push(row);
        }

        // Column headers: only show up to second-to-last group
        const header = '<th></th>' + groupNames.slice(0, -1).map(n => {
          const agentType = parseAgentType(n);
          const modelName = extractModelName(n);
          const modelFamily = parseModelFamily(modelName);
          return '<th><span class="corr-col-label">' + createAgentChip(agentType, true) + createModelChip(modelFamily, modelName, true) + '</span></th>';
        }).join('');
        
        // Rows: start from second group
        const rows = matrix.slice(1).map((row, idx) => {
          const i = idx + 1;
          const agentType = parseAgentType(groupNames[i]);
          const modelName = extractModelName(groupNames[i]);
          const modelFamily = parseModelFamily(modelName);
          // Only render cells up to (but not including) the diagonal
          const cells = row.slice(0, -1).map(cell => {
            const val = cell.r;
            const bg = corrColor(val);
            const text = val !== null ? val.toFixed(3) : '-';
            const title = 'n=' + cell.n + ' paired items';
            return '<td class="corr-cell" style="background:' + bg + '" title="' + title + '">' + text + '</td>';
          }).join('');
          return '<tr><th style="text-align:right;">' + createAgentChip(agentType, true) + ' ' + createModelChip(modelFamily, modelName, true) + '</th>' + cells + '</tr>';
        }).join('');

        elCompareCorrTable.innerHTML = '<thead><tr>' + header + '</tr></thead><tbody>' + rows + '</tbody>';

        const repNote = groups.some(g => g.runs.length > 1) ? ' Scores averaged across reps within each group.' : '';
        elCompareCorrNote.textContent = 'Pearson correlation on "' + metric + '". Min paired items: ' + (minPairs === Infinity ? 0 : minPairs) + '.' + repNote;
      }

      /* ═══════════════════════════════════
       *  Model Comparison Section
       * ═══════════════════════════════════ */
      let modelMetricChart = null;
      const elModelMetricSelect = document.getElementById('model-metric-select');

      /**
       * Group all runs by model family (GPT-5, GPT-5-mini, etc.)
       * Returns: { modelFamily: { name, runs: [...], items: [...] } }
       */
      function groupRunsByModel(runs) {
        const modelGroups = {};
        
        runs.forEach(run => {
          const modelName = extractModelName(run.run_name);
          const modelFamily = parseModelFamily(modelName);
          
          if (!modelGroups[modelFamily]) {
            modelGroups[modelFamily] = {
              name: MODEL_COLORS[modelFamily]?.name || modelFamily,
              runs: [],
              items: [],
            };
          }
          
          modelGroups[modelFamily].runs.push(run);
          
          // Collect all item_rows from this run
          const rd = allRunsData[run.run_name];
          if (rd?.item_rows) {
            rd.item_rows.forEach(row => {
              if (!row.failed) {
                modelGroups[modelFamily].items.push(row);
              }
            });
          }
        });
        
        return modelGroups;
      }

      /**
       * Build metric options for model comparison.
       */
      function buildModelMetricOptions() {
        const names = new Set();
        compareRuns.forEach(r => Object.keys(r.metrics || {}).forEach(n => names.add(n)));
        Object.values(allRunsData).forEach(rd => {
          (rd.item_rows || []).forEach(row => {
            Object.keys(row.metrics || {}).forEach(n => names.add(n));
          });
        });
        // Add computed metrics
        COMPUTED_METRICS.forEach(m => names.add(m));
        
        // Prefer f1 as default
        const defaultMetric = Array.from(names).find(n => n.toLowerCase() === 'avg_f1' || n.toLowerCase() === 'f1') || Array.from(names)[0] || '';
        elModelMetricSelect.innerHTML = buildGroupedMetricOptionsHTML(names, defaultMetric);
      }

      /**
       * Render all Model Comparison charts.
       */
      function renderModelComparison() {
        const runs = getSelectedRuns();
        const metric = elModelMetricSelect?.value || 'avg_f1';
        
        if (runs.length === 0) {
          // Hide section content if no runs
          return;
        }
        
        const modelGroups = groupRunsByModel(runs);
        const modelFamilies = Object.keys(modelGroups).sort();
        
        if (modelFamilies.length === 0) return;
        
        // Get model colors and labels
        const modelLabels = modelFamilies.map(m => modelGroups[m].name);
        const modelColors = modelFamilies.map(m => getModelColor(m));
        
        // Metric by Model (includes tool_precision, tool_recall, missed_opportunity_rate, latency, tool_usage via dropdown)
        renderModelMetricChart(modelGroups, modelFamilies, modelLabels, modelColors, metric);
      }

      function renderModelMetricChart(modelGroups, modelFamilies, modelLabels, modelColors, metric) {
        // Update chart title
        const title = document.getElementById('model-metric-title');
        if (title) {
          const displayName = METRIC_DISPLAY_NAMES[metric] || metric.replace(/^avg_/, '').replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
          title.textContent = displayName + ' by Model';
        }
        
        // Show/hide stacked toggle for applicable metrics
        const stackToggle = document.getElementById('model-stack-toggle');
        if (stackToggle) {
          stackToggle.style.display = TOOL_STACKABLE_METRICS.includes(metric) ? 'block' : 'none';
        }
        
        if (modelMetricChart) modelMetricChart.destroy();
        
        // Special handling for tool_usage - always stacked (counts sum to total)
        if (metric === 'tool_usage') {
          // Update description
          const descEl = document.getElementById('model-metric-description');
          if (descEl) {
            descEl.textContent = getMetricDescription(metric, true);
          }
          renderModelToolUsageStackedChart(modelGroups, modelFamilies, modelLabels);
          return;
        }
        
        // Special handling for stackable tool metrics - use toggle preference
        if (TOOL_STACKABLE_METRICS.includes(metric)) {
          const useStacked = document.getElementById('model-stacked-checkbox')?.checked ?? false;
          // Update description
          const descEl = document.getElementById('model-metric-description');
          if (descEl) {
            descEl.textContent = getMetricDescription(metric, useStacked);
          }
          renderModelToolMetricChart(modelGroups, modelFamilies, modelLabels, metric, useStacked);
          return;
        }
        
        // Update description for non-tool metrics
        const descEl = document.getElementById('model-metric-description');
        if (descEl) {
          descEl.textContent = getMetricDescription(metric, false);
        }
        
        // Calculate metric stats per model - aggregate per RUN first, then summarize across runs
        // This gives meaningful min/max/sd (variance between runs) rather than per-item variance
        const modelStats = modelFamilies.map(m => {
          const runs = modelGroups[m].runs;
          
          // Get per-run metric values using the same logic as Run Comparison
          const runValues = runs
            .map(run => getRunMetricValue(run, metric))
            .filter(v => v !== null && v !== undefined && !Number.isNaN(v));
          
          return summarize(runValues);
        });
        
        const usePercentage = isPercentageMetric(metric);
        const data = modelStats.map(s => s.mean);
        const maxVal = Math.max(...data.filter(v => v !== null), 0);
        // Dynamic scaling: round up to nearest 5% for percentage metrics, add 20% headroom for others
        const yMax = usePercentage 
          ? Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1)
          : Math.ceil(maxVal * 1.2);
        
        modelMetricChart = new Chart(document.getElementById('model-metric-chart').getContext('2d'), {
          type: 'bar',
          data: {
            labels: modelLabels,
            datasets: [{
              data: data,
              backgroundColor: modelColors.map(c => c + 'CC'),
              borderColor: modelColors,
              borderWidth: 2,
              errorBars: modelStats.map(s => s.n > 1 ? { min: s.min, max: s.max } : null),
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const s = modelStats[ctx.dataIndex];
                    if (!s || s.mean === null) return '';
                    const format = usePercentage ? (v => (v * 100).toFixed(1) + '%') : (v => fmt(v, 3));
                    return [
                      `Mean: ${format(s.mean)}`,
                      `SD: ${format(s.sd)}`,
                      `Min: ${format(s.min)}`,
                      `Max: ${format(s.max)}`,
                      `Runs: ${s.n}`,
                    ];
                  }
                }
              }
            },
            scales: {
              x: { grid: { display: false } },
              y: {
                beginAtZero: true,
                max: yMax,
                ticks: usePercentage ? { callback: (v) => (v * 100).toFixed(0) + '%' } : {},
                title: { display: true, text: metric.replace(/^avg_/, ''), font: { size: 11 } }
              }
            }
          }
        });
      }
      
      /**
       * Render stacked bar chart for tool usage by model.
       * Shows Search, SQL, SPARQL tool calls stacked per model.
       */
      function renderModelToolUsageStackedChart(modelGroups, modelFamilies, modelLabels) {
        const toolNames = ['search_entities_tool', 'execute_sql_query_tool', 'execute_sparql_query_tool'];
        const toolDisplayNames = toolNames.map(getToolDisplayName);
        
        const datasets = toolNames.map((toolName, idx) => {
          const data = modelFamilies.map(m => {
            const items = modelGroups[m].items;
            let total = 0;
            items.forEach(row => {
              total += row.tool_counts?.[toolName] || 0;
            });
            // Return average per item
            return items.length > 0 ? total / items.length : 0;
          });
          
          const color = getToolColor(toolName);
          return {
            label: toolDisplayNames[idx],
            data: data,
            backgroundColor: color + 'CC',
            borderColor: color,
            borderWidth: 1,
          };
        });
        
        modelMetricChart = new Chart(document.getElementById('model-metric-chart').getContext('2d'), {
          type: 'bar',
          data: {
            labels: modelLabels,
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { font: { size: 10 }, boxWidth: 12 }
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => `${ctx.dataset.label}: ${ctx.raw.toFixed(2)} calls/item`
                }
              }
            },
            scales: {
              x: { stacked: true, grid: { display: false } },
              y: {
                stacked: true,
                beginAtZero: true,
                title: { display: true, text: 'Avg Calls / Item', font: { size: 11 } }
              }
            }
          }
        });
      }
      
      /**
       * Unified function to render tool metric charts in Model Comparison.
       * Supports both stacked and grouped layouts based on useStacked parameter.
       * @param {Object} modelGroups - Model groups with items
       * @param {Array} modelFamilies - List of model family keys
       * @param {Array} modelLabels - Display labels for models
       * @param {string} metric - The metric to display
       * @param {boolean} useStacked - Whether to stack bars
       */
      function renderModelToolMetricChart(modelGroups, modelFamilies, modelLabels, metric, useStacked) {
        const toolNames = ['search_entities_tool', 'execute_sql_query_tool', 'execute_sparql_query_tool'];
        const toolDisplayNames = toolNames.map(getToolDisplayName);
        const isRateMetric = metric === 'tool_error_rate' || metric === 'zero_result_rate';
        
        const yAxisLabel = metric === 'tool_error_rate' ? 'Error Rate' :
                          metric === 'zero_result_rate' ? 'Zero Result Rate' :
                          metric === 'tool_precision' ? 'Precision' :
                          metric === 'tool_recall' ? 'Recall' : metric;
        
        // For stacked rate metrics, calculate total calls per model for common denominator
        const modelTotals = modelFamilies.map(m => {
          const items = modelGroups[m].items;
          let totalCalls = 0;
          items.forEach(row => {
            if (metric === 'tool_error_rate') {
              totalCalls += row.tool_error_stats?.total_calls || 0;
            } else if (metric === 'zero_result_rate') {
              totalCalls += row.zero_result_stats?.total_queries || 0;
            }
          });
          return totalCalls;
        });
        
        const datasets = toolNames.map((toolName, idx) => {
          const data = modelFamilies.map((m, modelIdx) => {
            const items = modelGroups[m].items;
            let totalA = 0;  // numerator
            let totalB = 0;  // denominator (tool-specific)
            
            items.forEach(row => {
              if (metric === 'tool_error_rate') {
                const byTool = row.tool_error_stats?.by_tool || {};
                const toolStats = byTool[toolName];
                if (toolStats) {
                  totalA += toolStats.errors || 0;
                  totalB += toolStats.total || 0;
                }
              } else if (metric === 'zero_result_rate') {
                const byTool = row.zero_result_stats?.by_tool || {};
                const toolStats = byTool[toolName];
                if (toolStats) {
                  totalA += toolStats.zero || 0;
                  totalB += toolStats.total || 0;
                }
              } else if (metric === 'tool_precision' || metric === 'tool_recall') {
                const gtd = row.gt_discovery || {};
                const progression = metric === 'tool_precision' 
                  ? gtd.precision_by_call_index 
                  : gtd.recall_by_call_index;
                if (progression && progression.length > 0) {
                  const lastEntry = progression[progression.length - 1];
                  const toolContributions = lastEntry[2] || {};
                  const toolValue = toolContributions[toolName];
                  if (toolValue !== undefined) {
                    totalA += toolValue;
                    totalB++;
                  }
                }
              }
            });
            
            // For rate metrics in stacked mode, use common denominator
            if (isRateMetric && useStacked) {
              const commonDenom = modelTotals[modelIdx];
              return commonDenom > 0 ? totalA / commonDenom : 0;
            }
            return totalB > 0 ? totalA / totalB : 0;
          });
          
          const color = getToolColor(toolName);
          return {
            label: toolDisplayNames[idx],
            data: data,
            backgroundColor: color + 'CC',
            borderColor: color,
            borderWidth: 1,
            // Store per-tool rates for tooltip in stacked mode
            _perToolRates: isRateMetric && useStacked ? modelFamilies.map(m => {
              const items = modelGroups[m].items;
              let toolNumerator = 0;
              let toolDenominator = 0;
              items.forEach(row => {
                const byTool = metric === 'tool_error_rate' 
                  ? row.tool_error_stats?.by_tool 
                  : row.zero_result_stats?.by_tool;
                const toolStats = byTool?.[toolName];
                if (toolStats) {
                  toolNumerator += metric === 'tool_error_rate' ? (toolStats.errors || 0) : (toolStats.zero || 0);
                  toolDenominator += toolStats.total || 0;
                }
              });
              return toolDenominator > 0 ? toolNumerator / toolDenominator : 0;
            }) : null
          };
        });
        
        // Calculate dynamic y-axis max
        let yMax;
        if (useStacked) {
          // For stacked charts, calculate max of sums across all groups
          const stackedMaxes = modelLabels.map((_, idx) => {
            return datasets.reduce((sum, ds) => sum + (ds.data[idx] || 0), 0);
          });
          const maxVal = stackedMaxes.length > 0 ? Math.max(...stackedMaxes) : 0;
          yMax = Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1);
        } else {
          // For grouped charts, calculate max of individual values
          const allValues = datasets.flatMap(ds => ds.data).filter(v => v != null);
          const maxVal = allValues.length > 0 ? Math.max(...allValues) : 0;
          yMax = Math.min(Math.ceil((maxVal + 0.05) * 20) / 20, 1);
        }
        
        modelMetricChart = new Chart(document.getElementById('model-metric-chart').getContext('2d'), {
          type: 'bar',
          data: {
            labels: modelLabels,
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { font: { size: 10 }, boxWidth: 12 }
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    // For stacked rate metrics, show both contribution and per-tool rate
                    if (isRateMetric && useStacked && ctx.dataset._perToolRates) {
                      const contribution = (ctx.raw * 100).toFixed(1);
                      const perToolRate = (ctx.dataset._perToolRates[ctx.dataIndex] * 100).toFixed(1);
                      return `${ctx.dataset.label}: ${contribution}% of total (${perToolRate}% of ${ctx.dataset.label} calls)`;
                    }
                    return `${ctx.dataset.label}: ${(ctx.raw * 100).toFixed(1)}%`;
                  }
                }
              }
            },
            scales: {
              x: { stacked: useStacked, grid: { display: false } },
              y: {
                stacked: useStacked,
                beginAtZero: true,
                max: yMax,
                ticks: { callback: (v) => (v * 100).toFixed(0) + '%' },
                title: { display: true, text: yAxisLabel, font: { size: 11 } }
              }
            }
          }
        });
      }
      


      function renderComparison() {
        const runs   = getSelectedRuns();
        const metric = elMetricSel.value;

        if (runs.length === 0) {
          elScoreTable.innerHTML = '<thead><tr><th>Item ID</th><th>Query</th></tr></thead>';
          document.getElementById('compare-corr-matrix-table').innerHTML = '<tbody><tr><td style="color:var(--muted)">Select runs to see correlation.</td></tr></tbody>';
          document.getElementById('compare-corr-note').textContent = '';
          if (metricChartInst) { metricChartInst.destroy(); metricChartInst = null; }
          return;
        }
        
        renderMetricChart(runs, metric);
        renderCompareCorrMatrix(runs, metric);
        
        // Update item comparison table (uses selected runs but its own metric)
        renderItemComparison();
        
        // Model comparison (uses same runs)
        renderModelComparison();
      }

      function initRunComparison() {
        if (compareRuns.length === 0) {
          // No runs to compare, show empty state
          elScoreTable.innerHTML =
            '<thead><tr><th>Item ID</th><th>Query</th></tr></thead>' +
            '<tbody><tr><td colspan="2" style="color:var(--muted)">No runs found to compare.</td></tr></tbody>';
          return;
        }
        const groups = groupRuns(compareRuns);
        elRunsSel.innerHTML = groups
          .map(g => {
            const n = g.runs.length;
            const agentType = parseAgentType(g.groupName);
            const modelName = extractModelName(g.groupName);
            const agentLabel = AGENT_COLORS[agentType]?.name || 'Auto';
            const repsLabel = n > 1 ? ' (' + n + ' reps)' : '';
            // For select options, use text label since HTML won't render
            const label = agentLabel + ' + ' + modelName + repsLabel;
            return '<option value="' + g.groupName + '" selected>' + label + '</option>';
          })
          .join('');
        buildMetricOptions();
        buildModelMetricOptions();
        buildItemCompareMetricOptions();
        renderComparison();
        renderItemComparison();
      }
      
      function initModelComparison() {
        if (compareRuns.length === 0) return;
        buildModelMetricOptions();
        renderModelComparison();
      }
      
      /**
       * Build metric options for the item comparison dropdown.
       * Uses the same grouped metric options as the run comparison metric dropdown.
       */
      function buildItemCompareMetricOptions() {
        if (!elItemCompareMetricSel) return;
        
        const names = new Set();
        compareRuns.forEach(r => Object.keys(r.metrics || {}).forEach(n => names.add(n)));
        Object.values(allRunsData).forEach(rd => {
          (rd.item_rows || []).forEach(row => {
            if (row.tool_calls_total !== undefined) names.add('tool_calls_total');
            Object.keys(row.tool_counts || {}).forEach(t => names.add(t + '_count'));
          });
        });
        // Add computed metrics
        COMPUTED_METRICS.forEach(m => names.add(m));
        
        // Prefer f1 as default if available
        const defaultMetric = Array.from(names).find(n => n.toLowerCase() === 'avg_f1' || n.toLowerCase() === 'f1') || Array.from(names)[0] || '';
        elItemCompareMetricSel.innerHTML = buildGroupedMetricOptionsHTML(names, defaultMetric);
      }
      
      function renderItemComparison() {
        const runs = getSelectedRuns();
        const metric = elItemCompareMetricSel?.value || 'avg_f1';
        
        if (runs.length === 0) {
          elScoreTable.innerHTML = '<thead><tr><th>Item ID</th><th>Query</th></tr></thead>';
          return;
        }
        
        const collected = collectItemScores(runs, metric);
        renderScoreTable(runs, metric, collected);
        
        // Update query details options when runs change
        if (typeof buildQueryDetailOptions === 'function') {
          buildQueryDetailOptions();
          if (selectedQueryId) {
            renderQueryRunsSummary(selectedQueryId);
            if (selectedRunName) {
              renderQueryDetailContent();
            }
            updateScoreTableSelection();
          }
        }
      }
      
      // Initial render
      initRunComparison();
      
      // Initialize Query Details section (after runs are loaded)
      initQueryDetails();

      elRunsSel.addEventListener('change', renderComparison);
      elMetricSel.addEventListener('change', renderComparison);
      
      // Run Comparison stacked toggle
      const elCompareStackedCheckbox = document.getElementById('compare-stacked-checkbox');
      if (elCompareStackedCheckbox) {
        elCompareStackedCheckbox.addEventListener('change', renderComparison);
      }
      
      // Model comparison metric selector
      if (elModelMetricSelect) {
        elModelMetricSelect.addEventListener('change', renderModelComparison);
      }
      
      // Model Comparison stacked toggle
      const elModelStackedCheckbox = document.getElementById('model-stacked-checkbox');
      if (elModelStackedCheckbox) {
        elModelStackedCheckbox.addEventListener('change', renderModelComparison);
      }
      
      // Item comparison metric selector (dedicated dropdown for item comparison section)
      if (elItemCompareMetricSel) {
        elItemCompareMetricSel.addEventListener('change', renderItemComparison);
      }

      /* ═══════════════════════════════════
       *  10. Theme toggle
       * ═══════════════════════════════════ */
      (function initThemeToggle() {
        const btn = document.getElementById('theme-toggle');
        function updateIcon() {
          btn.innerHTML = isDarkMode() ? '&#9788;' : '&#9790;';
        }
        updateIcon();

        btn.addEventListener('click', () => {
          const next = isDarkMode() ? 'light' : 'dark';
          document.documentElement.setAttribute('data-theme', next);
          localStorage.setItem('stark-report-theme', next);
          updateIcon();
          applyChartTheme();
          
          // Refresh color legend
          const legendContainer = document.getElementById('color-legend-container');
          if (legendContainer && compareRuns.length > 0) {
            legendContainer.innerHTML = generateColorLegend();
          }
          
          // Refresh charts and correlation matrix with updated colors
          const selectedRuns = getSelectedRuns();
          if (selectedRuns.length > 0) {
            renderMetricChart(selectedRuns, elMetricSel.value);
            renderCompareCorrMatrix(selectedRuns, elMetricSel.value);
          }
          
          // Re-apply heatmap with correct metric from item comparison dropdown
          const itemMetric = elItemCompareMetricSel?.value || 'avg_f1';
          applyHeatmap(elScoreTable, itemMetric);
        });
      })();

      /* ═══════════════════════════════════
       *  11. Dataset selector initialization
       * ═══════════════════════════════════ */
      // Initialize dataset selector (must be after all render functions are defined)
      initDatasetSelector();
    </script>
  </body>
</html>
